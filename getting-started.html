

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. Getting Started &mdash; Cloud Haskell User Guide</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Cloud Haskell User Guide" href="index.html"/>
        <link rel="next" title="2. Overview" href="2ch.html"/>
        <link rel="prev" title="Welcome to Haskell Distributed’s documentation!" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Cloud Haskell
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-project">1.1. Setting up the project</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-node">1.2. Creating a node</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sending-messages">1.3. Sending messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#serializable-data">1.4. Serializable Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spawning-remote-processes">1.5. Spawning Remote Processes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2ch.html">2. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="3ch.html">3. Message Ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="4ch.html">4. Managed Process Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html">5. ![Sup1: ][sup1]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup2-sup2">6. ![Sup2: ][sup2]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup3-sup3">7. ![Sup3: ][sup3]</a></li>
<li class="toctree-l1"><a class="reference internal" href="6ch.html">8. Advanced Managed Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-NT2.html">9. Programming with Network.Transport</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Cloud Haskell</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>1. Getting Started</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/getting-started.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>1. Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>In order to go through this tutorial, you will need a working Haskell
environment. If you don&#8217;t already have one follow the instructions
<a class="reference external" href="https://www.haskell.org/downloads">here</a> to install the compiler and
then
<a class="reference external" href="https://github.com/commercialhaskell/stack/wiki/Downloads">go here</a>
to install <code class="docutils literal"><span class="pre">stack</span></code>, a popular build tool for Haskell projects.</p>
<p>Once you&#8217;re up and running, you&#8217;ll want to get hold of the
<code class="docutils literal"><span class="pre">distributed-process</span></code> library and a choice of network transport
backend. This guide will use the <code class="docutils literal"><span class="pre">network-transport-tcp</span></code> backend, but
other backends are available on <a class="reference external" href="https://hackage.haskell.org">Hackage</a>
and <a class="reference external" href="https://github.com">GitHub</a>.</p>
<div class="section" id="setting-up-the-project">
<h2>1.1. Setting up the project<a class="headerlink" href="#setting-up-the-project" title="Permalink to this headline">¶</a></h2>
<p>Starting a new Cloud Haskell project using <code class="docutils literal"><span class="pre">stack</span></code> is as easy as</p>
<blockquote>
<div>$ stack new</div></blockquote>
<p>in a fresh new directory. This will populate the directory with
a number of files, chiefly <code class="docutils literal"><span class="pre">stack.yaml</span></code> and <code class="docutils literal"><span class="pre">*.cabal</span></code> metadata files
for the project. You&#8217;ll want to add <code class="docutils literal"><span class="pre">distributed-process</span></code> and
<code class="docutils literal"><span class="pre">network-transport-tcp</span></code> to the <code class="docutils literal"><span class="pre">build-depends</span></code> stanza of the
executable section.</p>
</div>
<div class="section" id="creating-a-node">
<h2>1.2. Creating a node<a class="headerlink" href="#creating-a-node" title="Permalink to this headline">¶</a></h2>
<p>Cloud Haskell&#8217;s <em>lightweight processes</em> reside on a &#8220;node&#8221;, which must
be initialised with a network transport implementation and a remote table.
The latter is required so that physically separate nodes can identify known
objects in the system (such as types and functions) when receiving messages
from other nodes. We will look at inter-node communication later, for now
it will suffice to pass the default remote table, which defines the built-in
types that Cloud Haskell needs at a minimum in order to run.</p>
<p>In <code class="docutils literal"><span class="pre">app/Main.hs</span></code>, we start with our imports:</p>
<blockquote>
<div>import Network.Transport.TCP (createTransport, defaultTCPParameters)
import Control.Distributed.Process
import Control.Distributed.Process.Node</div></blockquote>
<p>Our TCP network transport backend needs an IP address and port to get started
with:</p>
<p>And now we have a running node.</p>
</div>
<div class="section" id="sending-messages">
<h2>1.3. Sending messages<a class="headerlink" href="#sending-messages" title="Permalink to this headline">¶</a></h2>
<p>We start a new process by evaluating <code class="docutils literal"><span class="pre">runProcess</span></code>, which takes a node and
a <code class="docutils literal"><span class="pre">Process</span></code> action to run, because our concurrent code will run in the
<code class="docutils literal"><span class="pre">Process</span></code> monad. Each process has an identifier associated to it. The process
id can be used to send messages to the running process - here we will send one
to ourselves!</p>
<p>Note that we haven&#8217;t deadlocked our own thread by sending to and receiving
from its mailbox in this fashion. Sending messages is a completely
asynchronous operation - even if the recipient doesn&#8217;t exist, no error will be
raised and evaluating <code class="docutils literal"><span class="pre">send</span></code> will not block the caller, even if the caller is
sending messages to itself.</p>
<p>Each process also has a <em>mailbox</em> associated with it. Messages sent to
a process are queued in this mailbox. A process can pop a message out of its
mailbox using <code class="docutils literal"><span class="pre">expect</span></code> or the <code class="docutils literal"><span class="pre">receive*</span></code> family of functions. If no message of
the expected type is in the mailbox currently, the process will block until
there is. Messages in the mailbox are ordered by time of arrival.</p>
<p>Let&#8217;s spawn two processes on the same node and have them talk to each other:</p>
<p>Note that we&#8217;ve used <code class="docutils literal"><span class="pre">receiveWait</span></code> this time around to get a message.
<code class="docutils literal"><span class="pre">receiveWait</span></code> and similarly named functions can be used with the
[<code class="docutils literal"><span class="pre">Match</span></code> data type][5] to provide a range of advanced message
processing capabilities. The <code class="docutils literal"><span class="pre">match</span></code> primitive allows you to construct
a &#8220;potential message handler&#8221; and have it evaluated against received
(or incoming) messages. Think of a list of <code class="docutils literal"><span class="pre">Match``es</span> <span class="pre">as</span> <span class="pre">the</span>
<span class="pre">distributed</span> <span class="pre">equivalent</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">pattern</span> <span class="pre">match.</span> <span class="pre">As</span> <span class="pre">with</span> <span class="pre">``expect</span></code>, if the
mailbox does not contain a message that can be matched, the evaluating
process will be blocked until a message arrives which _can_ be
matched.</p>
<p>In the <em>echo server</em> above, our first match prints out whatever string it
receives. If the first message in our mailbox is not a <code class="docutils literal"><span class="pre">String</span></code>, then our
second match is evaluated. Thus, given a tuple <code class="docutils literal"><span class="pre">t</span> <span class="pre">::</span> <span class="pre">(ProcessId,</span> <span class="pre">String)</span></code>, it
will send the <code class="docutils literal"><span class="pre">String</span></code> component back to the sender&#8217;s <code class="docutils literal"><span class="pre">ProcessId</span></code>. If neither
match succeeds, the echo server blocks until another message arrives and tries
again.</p>
</div>
<div class="section" id="serializable-data">
<h2>1.4. Serializable Data<a class="headerlink" href="#serializable-data" title="Permalink to this headline">¶</a></h2>
<p>Processes may send any datum whose type implements the <code class="docutils literal"><span class="pre">Serializable</span></code>
typeclass, defined as:</p>
<blockquote>
<div>class (Binary a, Typeable) =&gt; Serializable a
instance (Binary a, Typeable a) =&gt; Serializable a</div></blockquote>
<p>That is, any type that is <code class="docutils literal"><span class="pre">Binary</span></code> and <code class="docutils literal"><span class="pre">Typeable</span></code> is <code class="docutils literal"><span class="pre">Serializable</span></code>. This is
the case for most of Cloud Haskell&#8217;s primitive types as well as many standard
data types. For custom data types, the <code class="docutils literal"><span class="pre">Typeable</span></code> instance is always
given by the compiler, and the <code class="docutils literal"><span class="pre">Binary</span></code> instance can be auto-generated
too in most cases, e.g.:</p>
<blockquote>
<div><p>{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}</p>
<p>data T = T Int Char deriving (Generic, Typeable)</p>
<p>instance Binary T</p>
</div></blockquote>
</div>
<div class="section" id="spawning-remote-processes">
<h2>1.5. Spawning Remote Processes<a class="headerlink" href="#spawning-remote-processes" title="Permalink to this headline">¶</a></h2>
<p>We saw above that the behaviour of processes is determined by an action in the
<code class="docutils literal"><span class="pre">Process</span></code> monad. However, actions in the <code class="docutils literal"><span class="pre">Process</span></code> monad, no more serializable
than actions in the <code class="docutils literal"><span class="pre">IO</span></code> monad. If we can&#8217;t serialize actions, then how can we
spawn processes on remote nodes?</p>
<p>The solution is to consider only <em>static</em> actions and compositions thereof.
A static action is always defined using a closed expression (intuitively, an
expression that could in principle be evaluated at compile-time since it does
not depend on any runtime arguments). The type of static actions in Cloud
Haskell is <cite>Closure (Process a)</cite>. More generally, a value of type <cite>Closure b</cite>
is a value that was constructed explicitly as the composition of symbolic
pointers and serializable values. Values of type <cite>Closure b</cite> are serializable,
even if values of type <cite>b</cite> might not be. For instance, while we can&#8217;t in general
send actions of type <cite>Process ()</cite>, we can construct a value of type <cite>Closure
(Process ())</cite> instead, containing a symbolic name for the action, and send
that instead. So long as the remote end understands the same meaning for the
symbolic name, this works just as well. A remote spawn then, takes a static
action and sends that across the wire to the remote node.</p>
<p>Static actions are not easy to construct by hand, but fortunately Cloud
Haskell provides a little bit of Template Haskell to help. If <cite>f :: T1 -&gt; T2</cite>
then</p>
<blockquote>
<div>$(mkClosure &#8216;f) :: T1 -&gt; Closure T2</div></blockquote>
<p>You can turn any top-level unary function into a <cite>Closure</cite> using <cite>mkClosure</cite>.
For curried functions, you&#8217;ll need to uncurry them first (i.e. &#8220;tuple up&#8221; the
arguments). However, to ensure that the remote side can adequately interpret
the resulting <cite>Closure</cite>, you&#8217;ll need to add a mapping in a so-called <em>remote
table</em> associating the symbolic name of a function to its value. Processes can
only be successfully spawned on remote nodes if all these remote nodes have
the same remote table as the local one.</p>
<p>We need to configure our remote table (see the [API reference][6] for
more details) and the easiest way to do this, is to let the library
generate the relevant code for us. For example:</p>
<p>{% highlight haskell %}
sampleTask :: (TimeInterval, String) -&gt; Process ()
sampleTask (t, s) = sleep t &gt;&gt; say s</p>
<p>remotable [&#8216;sampleTask]
{% endhighlight %}</p>
<p>The last line is a top-level Template Haskell splice. At the call site for
<cite>spawn</cite>, we can construct a <cite>Closure</cite> corresponding to an application of
<cite>sampleTask</cite> like so:</p>
<blockquote>
<div>($(mkClosure &#8216;sampleTask) (seconds 2, &#8220;foobar&#8221;))</div></blockquote>
<p>The call to <cite>remotable</cite> implicitly generates a remote table by inserting
a top-level definition <cite>__remoteTable :: RemoteTable -&gt; RemoteTable</cite> in our
module for us. We compose this with other remote tables in order to come up
with a final, merged remote table for all modules in our program:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Closure</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Node</span>
<span class="kr">import</span> <span class="nn">Network.Transport.TCP</span> <span class="p">(</span><span class="nf">createTransport</span><span class="p">,</span> <span class="nf">defaultTCPParameters</span><span class="p">)</span>

<span class="nf">sampleTask</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">sampleTask</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">liftIO</span> <span class="p">(</span><span class="n">threadDelay</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">say</span> <span class="n">s</span>

<span class="nf">remotable</span> <span class="p">[</span><span class="n">&#39;sampleTask</span><span class="p">]</span>

<span class="nf">myRemoteTable</span> <span class="ow">::</span> <span class="kt">RemoteTable</span>
<span class="nf">myRemoteTable</span> <span class="ow">=</span> <span class="kt">Main</span><span class="o">.</span><span class="n">__remoteTable</span> <span class="n">initRemoteTable</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">Right</span> <span class="n">transport</span> <span class="ow">&lt;-</span> <span class="n">createTransport</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="s">&quot;10501&quot;</span> <span class="n">defaultTCPParameters</span>
  <span class="n">node</span> <span class="ow">&lt;-</span> <span class="n">newLocalNode</span> <span class="n">transport</span> <span class="n">myRemoteTable</span>
  <span class="n">runProcess</span> <span class="n">node</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">us</span> <span class="ow">&lt;-</span> <span class="n">getSelfNode</span>
    <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">spawnLocal</span> <span class="o">$</span> <span class="n">sampleTask</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="s">&quot;using spawnLocal&quot;</span><span class="p">)</span>
    <span class="n">pid</span> <span class="ow">&lt;-</span> <span class="n">spawn</span> <span class="n">us</span> <span class="o">$</span> <span class="o">$</span><span class="p">(</span><span class="n">mkClosure</span> <span class="n">&#39;sampleTask</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="s">&quot;using spawn&quot;</span><span class="p">)</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">threadDelay</span> <span class="mi">2000000</span>
</pre></div>
</div>
<p>In the above example, we spawn <cite>sampleTask</cite> on node <cite>us</cite> in two
different ways:</p>
<ul class="simple">
<li>using <cite>spawn</cite>, which expects some node identifier to spawn a process
on along with a <cite>Closure</cite> for the action of the process.</li>
<li>using <cite>spawnLocal</cite>, a specialization of <cite>spawn</cite> for the case when the
node identifier actually refers to the local node (i.e. <cite>us</cite>). In
this special case, no serialization is necessary, so passing an
action directly rather than a <cite>Closure</cite> works just fine.</li>
</ul>
<hr class="docutils" />
<p>[1]: /static/doc/distributed-process/Control-Distributed-Process.html#v:Message
[2]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process">http://hackage.haskell.org/package/distributed-process</a>
[3]: /static/doc/distributed-process-platform/Control-Distributed-Process-Platform-Async.html
[4]: /static/doc/distributed-process-platform/Control-Distributed-Process-Platform-ManagedProcess.htmlv:callAsync
[5]: http://hackage.haskell.org/packages/archive/distributed-process/latest/doc/html/Control-Distributed-Process-Internal-Primitives.html#t:Match
[6]: http://hackage.haskell.org/packages/archive/distributed-process/latest/doc/html/Control-Distributed-Process-Closure.html</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="2ch.html" class="btn btn-neutral float-right" title="2. Overview" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to Haskell Distributed’s documentation!" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Haskell distributed team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>