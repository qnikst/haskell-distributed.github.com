

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3. Getting to know Processes &mdash; Cloud Haskell User Guide</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Cloud Haskell User Guide" href="index.html"/>
        <link rel="next" title="4. Distributed-process platform" href="managed-process.html"/>
        <link rel="prev" title="2. Managing Topologies" href="managing-topologies.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Cloud Haskell
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="tutorial/getting-started.html">1. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#setting-up-the-project">1.1. Setting up the project</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#creating-a-node">1.2. Creating a node</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#sending-messages">1.3. Sending messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#serializable-data">1.4. Serializable Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/getting-started.html#spawning-remote-processes">1.5. Spawning Remote Processes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="managing-topologies.html">2. Managing Topologies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="managing-topologies.html#overview">2.1. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="managing-topologies.html#a-simple-example">2.2. A Simple Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="managing-topologies.html#master-slave-configurations">2.3. Master Slave Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="managing-topologies.html#other-topologies-and-backends">2.4. Other Topologies and Backends</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">3. Getting to know Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#message-ordering">3.1. Message Ordering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#selective-receive">3.2. Selective Receive</a></li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-mailbox-processing">3.3. Advanced Mailbox Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typed-channels">3.4. Typed Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="#process-lifetime">3.5. Process Lifetime</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitoring-and-linking">3.6. Monitoring and Linking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-process-info">3.7. Getting Process Info</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monad-transformer-stacks">3.8. Monad Transformer Stacks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="managed-process.html">4. Distributed-process platform</a><ul>
<li class="toctree-l2"><a class="reference internal" href="managed-process.html#managed-process-tutorial">4.1. Managed Process Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#introduction">4.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#managed-processes">4.1.2. Managed Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#a-basic-example">4.1.3. A Basic Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#building-a-task-queue">4.1.4. Building a Task Queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#implementing-the-client">4.1.5. Implementing the client</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#implementing-the-server">4.1.6. Implementing the server</a></li>
<li class="toctree-l3"><a class="reference internal" href="managed-process.html#making-use-of-async">4.1.7. Making use of Async</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html">5. ![Sup1: ][sup1]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup2-sup2">6. ![Sup2: ][sup2]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup3-sup3">7. ![Sup3: ][sup3]</a></li>
<li class="toctree-l1"><a class="reference internal" href="6ch.html">8. Advanced Managed Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-NT2.html">9. Programming with Network.Transport</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Cloud Haskell</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>3. Getting to know Processes</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/getting-to-know-processes.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-to-know-processes">
<h1>3. Getting to know Processes<a class="headerlink" href="#getting-to-know-processes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="message-ordering">
<h2>3.1. Message Ordering<a class="headerlink" href="#message-ordering" title="Permalink to this headline">¶</a></h2>
<p>We have already met the <code class="docutils literal"><span class="pre">send</span></code> primitive, used to deliver messages from one
process to another. Here&#8217;s a review of what we&#8217;ve learned about <code class="docutils literal"><span class="pre">send</span></code> thus far:</p>
<ol class="arabic simple">
<li>sending is asynchronous (i.e., it does not block the caller)</li>
<li>sending <strong>never</strong> fails, regardless of the state of the recipient process</li>
<li>even if a message is received, there is <strong>no</strong> guarantee <strong>when</strong> it will arrive</li>
<li>there are <strong>no</strong> guarantees that the message will be received at all</li>
</ol>
<p>Asynchronous sending buys us several benefits. Improved concurrency is
possible, because processes need not block or wait for acknowledgements,
nor does error handling need to be implemented each time a message is sent.
Consider a stream of messages sent from one process to another. If the
stream consists of messages <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code>, <code class="docutils literal"><span class="pre">c</span></code> and we have seen <code class="docutils literal"><span class="pre">c</span></code>, then we know for
certain that we will have already seen <code class="docutils literal"><span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">b</span></code> (in that order), so long as the
messages were sent to us by the same peer process.</p>
<p>When two concurrent process exchange messages, Cloud Haskell guarantees that
messages will be delivered in FIFO order, if at all. No such guarantee exists
between $N$ processes where $N &gt; 1$, so if processes _A_ and _B_ are both
communicating (concurrently) with process _C_, the ordering guarantee will
only hold for each pair of interactions, i.e., between _A_ and _C_ and/or
_B_ and _C_ the ordering will be guaranteed, but not between _A_ and _B_
with regards messages sent to _C_.</p>
<p>Because the mailbox contains messages of varying types, when we <cite>expect</cite>
a message, we eschew the ordering because we&#8217;re searching for a message
whose contents can be decoded to a specific type. Of course, we may <strong>want</strong>
to process messages in the precise order which they arrived. To achieve
this, we must defer the type checking that would normally cause a traversal
of the mailbox and extract the _raw_ message ourselves. This can be achieved
using <cite>receive</cite> and <cite>matchAny</cite>, as we will demonstrate later.</p>
</div>
<div class="section" id="selective-receive">
<h2>3.2. Selective Receive<a class="headerlink" href="#selective-receive" title="Permalink to this headline">¶</a></h2>
<p>Processes dequeue messages (from their mailbox) using the [<cite>expect</cite>][1]
and [<cite>receive</cite>][2] family of primitives. Both take an optional timeout,
allowing the expression to evaluate to <cite>Nothing</cite> if no matching input
is found.</p>
<p>The [<cite>expect</cite>][1] primitive blocks until a message matching the expected type
(of the expression) is found in the process&#8217; mailbox. If a match is found by
scanning the mailbox, it is dequeued and returned, otherwise the caller
(i.e., the calling thread/process) is blocked until a message of the expected
type is delivered to the mailbox. Let&#8217;s take a look at this in action:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">demo</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">demo</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">listener</span> <span class="ow">&lt;-</span> <span class="n">spawnLocal</span> <span class="n">listen</span>
    <span class="n">send</span> <span class="n">listener</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">getSelfPid</span> <span class="o">&gt;&gt;=</span> <span class="n">send</span> <span class="n">listener</span>
    <span class="nb">()</span> <span class="ow">&lt;-</span> <span class="n">expect</span>
  <span class="kr">where</span>
    <span class="n">listen</span> <span class="ow">=</span> <span class="kr">do</span>
      <span class="n">third</span> <span class="ow">&lt;-</span> <span class="n">expect</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="kt">ProcessId</span>
      <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">expect</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="kt">String</span>
      <span class="n">second</span> <span class="ow">&lt;-</span> <span class="n">expectTimeout</span> <span class="mi">100000</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="kt">String</span>
      <span class="n">mapM_</span> <span class="p">(</span><span class="n">say</span> <span class="o">.</span> <span class="n">show</span><span class="p">)</span> <span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">]</span>
      <span class="n">send</span> <span class="n">third</span> <span class="nb">()</span>
</pre></div>
</div>
<p>This program will print <code class="docutils literal"><span class="pre">&quot;hello&quot;</span></code>, then <code class="docutils literal"><span class="pre">Nothing</span></code> and finally <code class="docutils literal"><span class="pre">pid://...</span></code>.
The first <code class="docutils literal"><span class="pre">expect</span></code> - labelled &#8220;third&#8221; because of the order in which we
know it will arrive in our mailbox - <strong>will</strong> succeed, since the parent process
sends its <code class="docutils literal"><span class="pre">ProcessId</span></code> after the string &#8220;hello&#8221;, yet the listener blocks until it
can dequeue the <code class="docutils literal"><span class="pre">ProcessId</span></code> before &#8220;expecting&#8221; a string. The second <code class="docutils literal"><span class="pre">expect</span></code>
(labelled &#8220;first&#8221;) also succeeds, demonstrating that the listener has selectively
removed messages from its mailbox based on their type rather than the order in
which they arrived. The third <code class="docutils literal"><span class="pre">expect</span></code> will timeout and evaluate to <code class="docutils literal"><span class="pre">Nothing</span></code>,
because only one string is ever sent to the listener and that has already been
removed from the mailbox. The removal of messages from the process&#8217; mailbox based
on type is what makes this program viable - without this &#8220;selective receiving&#8221;,
the program would block and never complete.</p>
<p>By contrast, the [<cite>receive</cite>][2] family of primitives take a list of <code class="docutils literal"><span class="pre">Match</span></code>
objects, each derived from evaluating a [<cite>match</cite>][3] style primitive. This
subject was covered briefly in the first tutorial. Matching on messages allows
us to separate the type(s) of messages we can handle from the type that the
whole <code class="docutils literal"><span class="pre">receive</span></code> expression evaluates to.</p>
<p>Consider the following snippet:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">usingReceive</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="nb">()</span> <span class="ow">&lt;-</span> <span class="n">receiveWait</span> <span class="p">[</span>
      <span class="n">match</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">s</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">say</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">match</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">i</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span>    <span class="ow">-&gt;</span> <span class="n">say</span> <span class="o">$</span> <span class="n">show</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Note that each of the matches in the list must evaluate to the same type,
as the type signature indicates: <code class="docutils literal"><span class="pre">receiveWait</span> <span class="pre">::</span> <span class="pre">[Match</span> <span class="pre">b]</span> <span class="pre">-&gt;</span> <span class="pre">Process</span> <span class="pre">b</span></code>.</p>
<p>The behaviour of <code class="docutils literal"><span class="pre">receiveWait</span></code> differs from <code class="docutils literal"><span class="pre">receiveTimeout</span></code> in that it
blocks forever (until a match is found in the process&#8217; mailbox), whereas the
variant taking a timeout will return <code class="docutils literal"><span class="pre">Nothing</span></code> unless a match is found within
the specified time interval. Note that as with <code class="docutils literal"><span class="pre">System.Timeout</span></code>, the only
guarantee we have about a timeout based function is that it will not
expire _before_ the given interval. Both functions scan the mailbox in FIFO
order, evaluating the list of <code class="docutils literal"><span class="pre">match</span></code> expressions in declarative
(i.e., insertion) order until one of the matches succeeds or the operation
times out.</p>
</div>
<div class="section" id="advanced-mailbox-processing">
<h2>3.3. Advanced Mailbox Processing<a class="headerlink" href="#advanced-mailbox-processing" title="Permalink to this headline">¶</a></h2>
<p>There are times when it is desirable to take a message from our mailbox without
explicitly specifying its type. Not only is this a useful capability, it is the
<em>only</em> way to process messages in the precise order they were received.</p>
<p>To see how this works in practise, let&#8217;s consider the <code class="docutils literal"><span class="pre">relay</span></code> primitive that
ships with distributed-process. This utility function starts a process that
simply dequeues _any_ messages it receives and forwards them to some other process.
In order to dequeue messages regardless of their type, this code relies on the
<code class="docutils literal"><span class="pre">matchAny</span></code> primitive, which has the following type:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">matchAny</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">Message</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Match</span> <span class="n">b</span>
</pre></div>
</div>
<p>Since forwarding <em>raw messages</em> (without decoding them first) is a common pattern
in Cloud Haskell programs, there is also a primitive to do that for us:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">forward</span> <span class="ow">::</span> <span class="kt">Message</span> <span class="ow">-&gt;</span> <span class="kt">ProcessId</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Given these types, we can see that in order to combine <code class="docutils literal"><span class="pre">matchAny</span></code> with <code class="docutils literal"><span class="pre">forward</span></code>
we need to either _flip_ <code class="docutils literal"><span class="pre">forward</span></code> and apply the <code class="docutils literal"><span class="pre">ProcessId</span></code> (leaving us with
the required type <code class="docutils literal"><span class="pre">Message</span> <span class="pre">-&gt;</span> <span class="pre">Process</span> <span class="pre">b</span></code>) or use a lambda - the actual implementation
does the latter and looks like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">relay</span> <span class="ow">::</span> <span class="kt">ProcessId</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">relay</span> <span class="o">!</span><span class="n">pid</span> <span class="ow">=</span> <span class="n">forever&#39;</span> <span class="o">$</span> <span class="n">receiveWait</span> <span class="p">[</span> <span class="n">matchAny</span> <span class="p">(</span><span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">forward</span> <span class="n">m</span> <span class="n">pid</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>This is pretty useful, but since <code class="docutils literal"><span class="pre">matchAny</span></code> operates on the raw <code class="docutils literal"><span class="pre">Message</span></code> type,
we&#8217;re limited in what we can do with the messages we receive. In order to delve
<em>inside</em> a message, we have to know its type. If we have an expression that operates
on a specific type, we can _attempt_ to decode the message to that type and examine
the result to see whether the decoding succeeds or not. There are two primitives
we can use to that effect: <code class="docutils literal"><span class="pre">unwrapMessage</span></code> and <code class="docutils literal"><span class="pre">handleMessage</span></code>. Their types look like
this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">unwrapMessage</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">m</span> <span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Serializable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Message</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>

<span class="nf">handleMessage</span> <span class="ow">::</span> <span class="n">forall</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span><span class="o">.</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Serializable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Message</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Of the two, <code class="docutils literal"><span class="pre">unwrapMessage</span></code> is the simpler, taking a raw <code class="docutils literal"><span class="pre">Message</span></code> and evaluating to
<code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></code> before returning that value in the monad <code class="docutils literal"><span class="pre">m</span></code>. If the type of the raw <code class="docutils literal"><span class="pre">Message</span></code>
does not match our expectation, the result will be <code class="docutils literal"><span class="pre">Nothing</span></code>, otherwise <code class="docutils literal"><span class="pre">Just</span> <span class="pre">a</span></code>.</p>
<p>The approach <cite>handleMessage</cite> takes is a bit more flexible, taking a function
from <cite>a -&gt; m b</cite> and returning <cite>Just b</cite> if the underlying message is of type <cite>a</cite> (hence the
operation can be executed and evaluate to <cite>Maybe b</cite>) or <cite>Nothing</cite> if the message&#8217;s type
is incompatible with the handler function.</p>
<p>Let&#8217;s look at <cite>handleMessage</cite> in action. Earlier on we looked at <cite>relay</cite> from
distributed-process and now we&#8217;ll consider its sibling <cite>proxy</cite> - this takes a predicate,
evaluates some input of type <cite>a</cite> and returns <cite>Process Bool</cite>, allowing us to run arbitrary
<cite>Process</cite> code in order to decide whether or not the <cite>a</cite> is eligible to be forwarded to
the relay <cite>ProcessId</cite>. The type of <cite>proxy</cite> is thus:</p>
<p>{% highlight haskell %}
proxy :: Serializable a =&gt; ProcessId -&gt; (a -&gt; Process Bool) -&gt; Process ()
{% endhighlight %}</p>
<p>Since <cite>matchAny</cite> operates on <cite>(Message -&gt; Process b)</cite> and <cite>handleMessage</cite> operates on
<cite>a -&gt; Process b</cite> we can compose these to make our proxy server. We must not forward
messages for which the predicate function evaluates to <cite>Just False</cite>, nor can we sensibly
forward messages which the predicate function is unable to evaluate due to type
incompatibility. This leaves us with the definition found in distributed-process:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">proxy</span> <span class="n">pid</span> <span class="n">proc</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">receiveWait</span> <span class="p">[</span>
      <span class="n">matchAny</span> <span class="p">(</span><span class="nf">\</span><span class="n">m</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
                   <span class="n">next</span> <span class="ow">&lt;-</span> <span class="n">handleMessage</span> <span class="n">m</span> <span class="n">proc</span>
                   <span class="kr">case</span> <span class="n">next</span> <span class="kr">of</span>
                     <span class="kt">Just</span> <span class="kt">True</span>  <span class="ow">-&gt;</span> <span class="n">forward</span> <span class="n">m</span> <span class="n">pid</span>
                     <span class="kt">Just</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>  <span class="c1">-- explicitly ignored</span>
                     <span class="kt">Nothing</span>    <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span><span class="p">)</span> <span class="c1">-- un-routable / cannot decode</span>
    <span class="p">]</span>
  <span class="n">proxy</span> <span class="n">pid</span> <span class="n">proc</span>
</pre></div>
</div>
<p>Beyond simple relays and proxies, the raw message handling capabilities available in
distributed-process can be utilised to develop highly generic message processing code.
All the richness of the distributed-process-platform APIs (such as <cite>ManagedProcess</cite>) which
will be discussed in later tutorials are, in fact, built upon these families of primitives.</p>
</div>
<div class="section" id="typed-channels">
<h2>3.4. Typed Channels<a class="headerlink" href="#typed-channels" title="Permalink to this headline">¶</a></h2>
<p>While being able to send and receive any <code class="docutils literal"><span class="pre">Serializable</span></code> datum is very powerful, the burden
of decoding types correctly at runtime is levied on the programmer and there are runtime
overheads to be aware of (which will be covered in later tutorials). Fortunately,
distributed-provides provides a type safe alternative to <code class="docutils literal"><span class="pre">send</span></code> and <code class="docutils literal"><span class="pre">receive</span></code>, in the form
of <em>Typed Channels</em>. Represented by distinct ends, a <cite>SendPort a</cite> (which is <code class="docutils literal"><span class="pre">Serializable</span></code>)
and <code class="docutils literal"><span class="pre">ReceivePort</span> <span class="pre">a</span></code> (which is not), channels are a lightweight and useful abstraction that
provides a type safe interface for interacting with processes separately from their primary
mailbox.</p>
<p>Channels are created with <code class="docutils literal"><span class="pre">newChan</span> <span class="pre">::</span> <span class="pre">Process</span> <span class="pre">(SendPort</span> <span class="pre">a,</span> <span class="pre">ReceivePort</span> <span class="pre">a)</span></code>, with
messages sent via <code class="docutils literal"><span class="pre">sendChan</span> <span class="pre">::</span> <span class="pre">SendPort</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Process</span> <span class="pre">()</span></code>. The <code class="docutils literal"><span class="pre">ReceivePort</span></code> can be
passed directly to <code class="docutils literal"><span class="pre">receiveChan</span></code>, or used in a <code class="docutils literal"><span class="pre">receive{Wait,</span> <span class="pre">Timeout}</span></code> call via the
<code class="docutils literal"><span class="pre">matchChan</span></code> primitive, so as to combine mailbox scans with channel reads.</p>
</div>
<div class="section" id="process-lifetime">
<h2>3.5. Process Lifetime<a class="headerlink" href="#process-lifetime" title="Permalink to this headline">¶</a></h2>
<p>A process will continue executing until it has evaluated to some value, or is abruptly
terminated either by crashing (with an un-handled exception) or being instructed to
stop executing. Deliberate stop instructions take one of two forms: a <cite>ProcessExitException</cite>
or <cite>ProcessKillException</cite>. As the names suggest, these _signals_ are delivered in the form
of asynchronous exceptions, however you should not to rely on that fact! After all,
we cannot throw an exception to a thread that is executing in some other operating
system process or on a remote host! Instead, you should use the [<cite>exit</cite>][5] and [<cite>kill</cite>][6]
primitives from distributed-process, which not only ensure that remote target processes
are handled seamlessly, but also maintain a guarantee that if you send a message and
<em>then</em> an exit signal, the message will be delivered to the destination process (via its
local node controller) before the exception is thrown - note that this does not guarantee
that the destination process will have time to <em>do anything</em> with the message before it
is terminated.</p>
<p>The <cite>ProcessExitException</cite> signal is sent from one process to another, indicating that the
receiver is being asked to terminate. A process can choose to tell itself to exit, and the
[<cite>die</cite>][7] primitive simplifies doing so without worrying about the expected type for the
action. In fact, [<cite>die</cite>][7] has slightly different semantics from [<cite>exit</cite>][5], since the
latter involves sending an internal signal to the local node controller. A direct consequence
of this is that the <em>exit signal</em> may not arrive immediately, since the <em>Node Controller</em> could
be busy processing other events. On the other hand, the [<cite>die</cite>][7] primitive throws a
<cite>ProcessExitException</cite> directly in the calling thread, thus terminating it without delay.
In practise, this means the following two functions could behave quite differently at
runtime:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- this will never print anything...</span>
<span class="nf">demo1</span> <span class="ow">=</span> <span class="n">die</span> <span class="s">&quot;Boom&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">expect</span> <span class="o">&gt;&gt;=</span> <span class="n">say</span>

<span class="c1">-- this /might/ print something before it exits</span>
<span class="nf">demo2</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">self</span> <span class="ow">&lt;-</span> <span class="n">getSelfPid</span>
  <span class="n">exit</span> <span class="n">self</span> <span class="s">&quot;Boom&quot;</span>
  <span class="n">expect</span> <span class="o">&gt;&gt;=</span> <span class="n">say</span>
</pre></div>
</div>
<p>The <cite>ProcessExitException</cite> type holds a _reason_ field, which is serialised as a raw <cite>Message</cite>.
This exception type is exported, so it is possible to catch these <em>exit signals</em> and decide how
to respond to them. Catching <em>exit signals</em> is done via a set of primitives in
distributed-process, and the use of them forms a key component of the various fault tolerance
strategies provided by distributed-process-platform.</p>
<p>A <cite>ProcessKillException</cite> is intended to be an _untrappable_ exit signal, so its type is
not exported and therefore you can __only__ handle it by catching all exceptions, which
as we all know is very bad practise. The [<cite>kill</cite>][6] primitive is intended to be a
<em>brutal</em> means for terminating process - e.g., it is used to terminate supervised child
processes that haven&#8217;t shutdown on request, or to terminate processes that don&#8217;t require
any special cleanup code to run when exiting - although it does behave like [<cite>exit</cite>][5]
in so much as it is dispatched (to the target process) via the <em>Node Controller</em>.</p>
</div>
<div class="section" id="monitoring-and-linking">
<h2>3.6. Monitoring and Linking<a class="headerlink" href="#monitoring-and-linking" title="Permalink to this headline">¶</a></h2>
<p>Processes can be linked to other processes (or nodes or channels). A link, which is
unidirectional, guarantees that once any object we have linked to <em>exits</em>, we will also
be terminated. A simple way to test this is to spawn a child process, link to it and then
terminate it, noting that we will subsequently die ourselves. Here&#8217;s a simple example,
in which we link to a child process and then cause it to terminate (by sending it a message
of the type it is waiting for). Even though the child terminates &#8220;normally&#8221;, our process
is also terminated since <cite>link</cite> will _link the lifetime of two processes <a href="#id1"><span class="problematic" id="id2">together_</span></a> regardless
of exit reasons.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">demo</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">pid</span> <span class="ow">&lt;-</span> <span class="n">spawnLocal</span> <span class="o">$</span> <span class="n">receive</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>
  <span class="n">link</span> <span class="n">pid</span>
  <span class="n">send</span> <span class="n">pid</span> <span class="nb">()</span>
  <span class="nb">()</span> <span class="ow">&lt;-</span> <span class="n">receive</span>
</pre></div>
</div>
<p>The medium that link failures uses to signal exit conditions is the same as exit and kill
signals - asynchronous exceptions. Once again, it is a bad idea to rely on this (not least
because it might change in some future release) and the exception type (<cite>ProcessLinkException</cite>)
is not exported so as to prevent developers from abusing exception handling code in this
special case. Since link exit signals cannot be caught directly, if you find yourself wanting
to <em>trap</em> a link failure, you probably want to use a monitor instead.</p>
<p>Whilst the built-in <cite>link</cite> primitive terminates the link-ee regardless of exit reason,
distributed-process-platform provides an alternate function <cite>linkOnFailure</cite>, which only
dispatches the <cite>ProcessLinkException</cite> if the link-ed process dies abnormally (i.e., with
some <cite>DiedReason</cite> other than <cite>DiedNormal</cite>).</p>
<p>Monitors on the other hand, do not cause the <em>listening</em> process to exit at all, instead
putting a <cite>ProcessMonitorNotification</cite> into the process&#8217; mailbox. This signal and its
constituent fields can be introspected in order to decide what action (if any) the receiver
can/should take in response to the monitored process&#8217; death. Let&#8217;s take a look at how
monitors can be used to determine both when and _how_ a process has terminated. Tucked
away in distributed-process-platform, the <cite>linkOnFailure</cite> primitive works in exactly this
way, only terminating the caller if the subject terminates abnormally. Let&#8217;s take a look...</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">linkOnFailure</span> <span class="n">them</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">us</span> <span class="ow">&lt;-</span> <span class="n">getSelfPid</span>
  <span class="n">tid</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">myThreadId</span>
  <span class="n">void</span> <span class="o">$</span> <span class="n">spawnLocal</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">callerRef</span> <span class="ow">&lt;-</span> <span class="kt">P</span><span class="o">.</span><span class="n">monitor</span> <span class="n">us</span>
    <span class="n">calleeRef</span> <span class="ow">&lt;-</span> <span class="kt">P</span><span class="o">.</span><span class="n">monitor</span> <span class="n">them</span>
    <span class="n">reason</span> <span class="ow">&lt;-</span> <span class="n">receiveWait</span> <span class="p">[</span>
             <span class="n">matchIf</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">ProcessMonitorNotification</span> <span class="n">mRef</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span>
                       <span class="n">mRef</span> <span class="o">==</span> <span class="n">callerRef</span><span class="p">)</span> <span class="c1">-- nothing left to do</span>
                     <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="kt">DiedNormal</span><span class="p">)</span>
           <span class="p">,</span> <span class="n">matchIf</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">ProcessMonitorNotification</span> <span class="n">mRef&#39;</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span>
                       <span class="n">mRef&#39;</span> <span class="o">==</span> <span class="n">calleeRef</span><span class="p">)</span>
                     <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="kt">ProcessMonitorNotification</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r&#39;</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">r&#39;</span><span class="p">)</span>
         <span class="p">]</span>
    <span class="kr">case</span> <span class="n">reason</span> <span class="kr">of</span>
      <span class="kt">DiedNormal</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="nb">()</span>
      <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">throwTo</span> <span class="n">tid</span> <span class="p">(</span><span class="kt">ProcessLinkException</span> <span class="n">us</span> <span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>As we can see, this code makes use of monitors to track both processes involved in the
link. In order to track <em>both</em> processes and react to changes in their status, it is
necessary to spawn a third process which will do the monitoring. This doesn&#8217;t happen
with the built-in link primitive, but is necessary in this case since the link handling
code resides outside the <em>Node Controller</em>.</p>
<p>The two matches passed to <cite>receiveWait</cite> both handle a <cite>ProcessMonitorNotification</cite>, and
the predicate passed to <cite>matchIf</cite> is used to determine whether the notification we&#8217;re
receiving is for the process that called us, or the _linked <a href="#id3"><span class="problematic" id="id4">to_</span></a> process. If the former
dies, we&#8217;ve nothing more to do, since links are unidirectional. If the latter dies
however, we must examine the <cite>DiedReason</cite> the <cite>ProcessMonitorNotification</cite> provides us
with, to determine whether the subject exited normally (i.e., with <cite>DiedNormal</cite>).
If the exit was _abnormal_, we throw a <cite>ProcessLinkException</cite> to the original caller,
which is exactly how an ordinary link would behave.</p>
<p>Linking and monitoring are foundational tools for <em>supervising</em> processes, where a top level
process manages a set of children, starting, stopping and restarting them as necessary.</p>
<p>Exit signals in Cloud Haskell then, are unlike asynchronous exceptions in other
haskell code. Whilst a process <em>can</em> use asynchronous exceptions - there&#8217;s
nothing stoping this since the <cite>Process</cite> monad is an instance of <cite>MonadIO</cite> -
as we&#8217;ve seen, exceptions thrown are not bound by the same ordering guarantees
as messages delivered to a process. Link failures and exit signals <em>might</em> work
via asynchronous exceptions - that is the case in the current implementation - but
these are implemented in such a fashion that if you send a message and <em>then</em> an
exit signal, the message is guaranteed to arrive first.</p>
<p>You should avoid throwing your own exceptions in code where possible. Instead,
you should terminate yourself, or another process, using the built-in primitives
<cite>exit</cite>, <cite>kill</cite> and <cite>die</cite>.</p>
</div>
<div class="section" id="getting-process-info">
<h2>3.7. Getting Process Info<a class="headerlink" href="#getting-process-info" title="Permalink to this headline">¶</a></h2>
<p>The <cite>getProcessInfo</cite> function provides a means for us to obtain information about a running
process. The <cite>ProcessInfo</cite> type it returns contains the local node id and a list of
registered names, monitors and links for the process. The call returns <cite>Nothing</cite> if the
process in question is not alive.</p>
</div>
<div class="section" id="monad-transformer-stacks">
<h2>3.8. Monad Transformer Stacks<a class="headerlink" href="#monad-transformer-stacks" title="Permalink to this headline">¶</a></h2>
<p>It is not generally necessary, but it may be convenient in your application to use a
custom monad transformer stack with the Process monad at the bottom. For example,
you may have decided that in various places in your application you will make calls to
a network database. You may create a data access module, and it will need configuration information available to it in
order to connect to the database server. A ReaderT can be a nice way to make
configuration data available throughout an application without
schlepping it around by hand.</p>
<p>This example is a bit contrived and over-simplified but
illustrates the concept. Consider the <cite>fetchUser</cite> function below, it runs in the <cite>AppProcess</cite>
monad which provides the configuration settings required to connect to the database:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.ByteString</span> <span class="p">(</span><span class="kt">ByteString</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Reader</span>

<span class="c1">-- imagine we have some database library</span>
<span class="kr">import</span> <span class="nn">Database.Imaginary</span> <span class="k">as</span> <span class="n">DB</span>

<span class="kr">data</span> <span class="kt">AppConfig</span> <span class="ow">=</span> <span class="kt">AppConfig</span> <span class="p">{</span><span class="n">dbHost</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">dbUser</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span>

<span class="kr">type</span> <span class="kt">AppProcess</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">AppConfig</span> <span class="kt">Process</span>

<span class="kr">data</span> <span class="kt">User</span> <span class="ow">=</span> <span class="kt">User</span> <span class="p">{</span><span class="n">userEmail</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">}</span>

<span class="c1">-- Perform a user lookup using our custom app context</span>
<span class="nf">fetchUser</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">AppProcess</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">User</span><span class="p">)</span>
<span class="nf">fetchUser</span> <span class="n">email</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">db</span> <span class="ow">&lt;-</span> <span class="n">openDB</span>
  <span class="n">user</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="kt">DB</span><span class="o">.</span><span class="n">query</span> <span class="n">db</span> <span class="n">email</span>
  <span class="n">closeDB</span> <span class="n">db</span>
  <span class="n">return</span> <span class="n">user</span>

<span class="nf">openDB</span> <span class="ow">::</span> <span class="kt">AppProcess</span> <span class="kt">DB</span><span class="o">.</span><span class="kt">Connection</span>
<span class="nf">openDB</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">AppConfig</span> <span class="n">host</span> <span class="n">user</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
  <span class="n">liftIO</span> <span class="o">$</span> <span class="kt">DB</span><span class="o">.</span><span class="n">connect</span> <span class="n">host</span> <span class="n">user</span>

<span class="nf">closeDB</span> <span class="ow">::</span> <span class="kt">DB</span><span class="o">.</span><span class="kt">Connection</span> <span class="ow">-&gt;</span> <span class="kt">AppProcess</span> <span class="nb">()</span>
<span class="nf">closeDB</span> <span class="n">db</span> <span class="ow">=</span> <span class="n">liftIO</span> <span class="p">(</span><span class="kt">DB</span><span class="o">.</span><span class="n">close</span> <span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
<p>So this would mostly work but it is not complete. What happens if an exception
is thrown by the <cite>query</cite> function? Your open database handle may not be
closed. Typically we manage this with the [bracket][brkt] function.</p>
<p>In the base library, [bracket][brkt] is defined in Control.Exception with this signature:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bracket</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="n">a</span>              <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="n">first</span> <span class="p">(</span><span class="s">&quot;acquire resource&quot;</span><span class="p">)</span>
        <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">b</span><span class="p">)</span> <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="n">last</span> <span class="p">(</span><span class="s">&quot;release resource&quot;</span><span class="p">)</span>
        <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">c</span><span class="p">)</span> <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="kr">in</span><span class="o">-</span><span class="n">between</span>
      <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">c</span>
</pre></div>
</div>
<p>Great! We pass an IO action that acquires a resource; <cite>bracket</cite> passes that
resource to a function which takes the resource and runs another action.
We also provide a release function which <cite>bracket</cite> is guaranteed to run
even if the primary action raises an exception.</p>
<p>Unfortunately, we cannot directly use <cite>bracket</cite> in our
<cite>fetchUser</cite> function: openDB (resource acquisition) runs in the <cite>AppProcess</cite>
monad. If our functions ran in IO, we could lift the entire bracket computation into
our monad transformer stack with liftIO; but we cannot do that for the computations
<em>passed</em> to bracket.</p>
<p>It is perfectly possible to write our own bracket; <cite>distributed-process</cite> does this
for the <cite>Process</cite> monad (which is itself a newtyped ReaderT stack). Here is how that is done:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- | Lift &#39;Control.Exception.bracket&#39;</span>
<span class="nf">bracket</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">c</span>
<span class="nf">bracket</span> <span class="n">before</span> <span class="n">after</span> <span class="n">thing</span> <span class="ow">=</span>
  <span class="n">mask</span> <span class="o">$</span> <span class="nf">\</span><span class="n">restore</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">before</span>
    <span class="n">r</span> <span class="ow">&lt;-</span> <span class="n">restore</span> <span class="p">(</span><span class="n">thing</span> <span class="n">a</span><span class="p">)</span> <span class="p">`</span><span class="n">onException</span><span class="p">`</span> <span class="n">after</span> <span class="n">a</span>
    <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">after</span> <span class="n">a</span>
    <span class="n">return</span> <span class="n">r</span>

<span class="nf">mask</span> <span class="ow">::</span> <span class="p">((</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Process</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">b</span>
<span class="nf">mask</span> <span class="n">p</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">lproc</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="kt">Ex</span><span class="o">.</span><span class="n">mask</span> <span class="o">$</span> <span class="nf">\</span><span class="n">restore</span> <span class="ow">-&gt;</span>
      <span class="n">runLocalProcess</span> <span class="n">lproc</span> <span class="p">(</span><span class="n">p</span> <span class="p">(</span><span class="n">liftRestore</span> <span class="n">restore</span><span class="p">))</span>
  <span class="kr">where</span>
    <span class="n">liftRestore</span> <span class="ow">::</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span>
                <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">a</span><span class="o">.</span> <span class="kt">Process</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">liftRestore</span> <span class="n">restoreIO</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">p2</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
      <span class="n">ourLocalProc</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
      <span class="n">liftIO</span> <span class="o">$</span> <span class="n">restoreIO</span> <span class="o">$</span> <span class="n">runLocalProcess</span> <span class="n">ourLocalProc</span> <span class="n">p2</span>

<span class="c1">-- | Lift &#39;Control.Exception.onException&#39;</span>
<span class="nf">onException</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="n">a</span>
<span class="nf">onException</span> <span class="n">p</span> <span class="n">what</span> <span class="ow">=</span> <span class="n">p</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="nf">\</span><span class="n">e</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">what</span>
                                        <span class="n">liftIO</span> <span class="o">$</span> <span class="n">throwIO</span> <span class="p">(</span><span class="n">e</span> <span class="ow">::</span> <span class="kt">SomeException</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>distributed-process</cite> needs to do this sort of thing to keep its dependency
list small, but do we really want to write this for every transformer stack
we use in our own applications? No! And we do not have to, thanks to
the [monad-control][mctrl] and [lifted-base][lbase] libraries.</p>
<p>[monad-control][mctrl] provides several typeclasses and helper functions
that make it possible to fully generalize the wrapping/unwrapping required
to keep transformer effects stashed away while actions run in the base monad. Of
most concern to end users of this library are the typeclass [MonadBase][mb] and [MonadBaseControl][mbc].
How it works is beyond the scope of this tutorial, but there is an excellent and thorough
explanation written by Michael Snoyman which is available [here][mctrlt].</p>
<p>[lifted-base][lbase] takes advantage of these typeclasses to provide lifted versions of many functions
in the Haskell base library. For example, [Control.Exception.Lifted][lexc] has a definition of
bracket that looks like this:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">bracket</span> <span class="ow">::</span> <span class="kt">MonadBaseControl</span> <span class="kt">IO</span> <span class="n">m</span>
        <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span>         <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="n">first</span> <span class="p">(</span><span class="s">&quot;acquire resource&quot;</span><span class="p">)</span>
        <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span>  <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="n">last</span> <span class="p">(</span><span class="s">&quot;release resource&quot;</span><span class="p">)</span>
        <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">c</span><span class="p">)</span>  <span class="o">--^</span> <span class="n">computation</span> <span class="n">to</span> <span class="n">run</span> <span class="kr">in</span><span class="o">-</span><span class="n">between</span>
        <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">c</span>
</pre></div>
</div>
<p>It is just the same as the version found in base, except it is generalized to work
with actions in any monad that implements [MonadBaseControl IO][mbc]. [monad-control][mctrl] defines
instances for the standard transformers, but that instance requires the base monad
(in this case, <cite>Process</cite>) to also have an instance of these classes.</p>
<p>To address this the [distributed-process-monad-control][dpmc] package
provides orphan instances of the <cite>Process</cite> type for both [MonadBase IO][mb] and [MonadBaseControl IO][mbc].
After importing these, we can rewrite our <cite>fetchUser</cite> function to use the instance of bracket
provided by [lifted-base][lbase].</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- ...</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Catch</span> <span class="k">as</span> <span class="n">Catch</span>

<span class="c1">-- ...</span>

<span class="nf">fetchUser</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">AppProcess</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">User</span><span class="p">)</span>
<span class="nf">fetchUser</span> <span class="n">email</span> <span class="ow">=</span>
  <span class="kt">Catch</span><span class="o">.</span><span class="n">bracket</span> <span class="n">openDB</span>
                <span class="n">closeDB</span>
          <span class="o">$</span> <span class="nf">\</span><span class="n">db</span> <span class="ow">-&gt;</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="kt">DB</span><span class="o">.</span><span class="n">query</span> <span class="n">db</span> <span class="n">email</span>
</pre></div>
</div>
<p>[lifted-base][lbase] also provides conveniences like [MVar][lmvar] and other concurrency primitives that
operate in [MonadBase IO][mb]. One benefit here is that your code is not sprinkled with
liftIO; but [MonadBaseControl IO][mbc] also makes things like a lifted [withMVar][lmvar-with] possible - which is
really just a specialization of [bracket][lbrkt]. You will also find lots of other libraries on hackage which
use these instances - at present count there are more than 150 [packages using it][reverse].</p>
<p>One note of caution: This instance can enable use of functions such as <cite>forkIO</cite> (or, <cite>fork</cite> from lifted-base[lbase]) which compromise invariants in the <cite>Process</cite> monad and can lead to confusing and subtle issues. Always use the Cloud Haskell functions such as spawnLocal instead.</p>
<p>[1]: hackage.haskell.org/package/distributed-process/docs/Control-Distributed-Process.html#v:receiveWait
[2]: hackage.haskell.org/package/distributed-process/docs/Control-Distributed-Process.html#v:expect
[3]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:match">http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:match</a>
[4]: /static/semantics.pdf
[5]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:exit">http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:exit</a>
[6]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:kill">http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:kill</a>
[7]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:die">http://hackage.haskell.org/package/distributed-process-0.4.2/docs/Control-Distributed-Process.html#v:die</a>
[brkt]: <a class="reference external" href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#v:bracket">http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#v:bracket</a>
[mctrl]: <a class="reference external" href="http://hackage.haskell.org/package/monad-control">http://hackage.haskell.org/package/monad-control</a>
[mb]: <a class="reference external" href="http://hackage.haskell.org/package/transformers-base-0.4.2/docs/Control-Monad-Base.html#t:MonadBase">http://hackage.haskell.org/package/transformers-base-0.4.2/docs/Control-Monad-Base.html#t:MonadBase</a>
[mbc]: <a class="reference external" href="http://hackage.haskell.org/package/monad-control-0.3.3.0/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl">http://hackage.haskell.org/package/monad-control-0.3.3.0/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl</a>
[lmvar]: <a class="reference external" href="http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Concurrent-MVar-Lifted.html#t:MVar">http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Concurrent-MVar-Lifted.html#t:MVar</a>
[lmvar-with]: <a class="reference external" href="http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Concurrent-MVar-Lifted.html#v:withMVar">http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Concurrent-MVar-Lifted.html#v:withMVar</a>
[lbrkt]: <a class="reference external" href="http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Exception-Lifted.html#v:bracket">http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Exception-Lifted.html#v:bracket</a>
[lbase]: <a class="reference external" href="http://hackage.haskell.org/package/lifted-base">http://hackage.haskell.org/package/lifted-base</a>
[dpmc]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-monad-control">http://hackage.haskell.org/package/distributed-process-monad-control</a>
[mctrlt]: <a class="reference external" href="http://www.yesodweb.com/book/monad-control">http://www.yesodweb.com/book/monad-control</a>
[reverse]: <a class="reference external" href="http://packdeps.haskellers.com/reverse/monad-control">http://packdeps.haskellers.com/reverse/monad-control</a>
[lexc]: <a class="reference external" href="http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Exception-Lifted.html">http://hackage.haskell.org/package/lifted-base-0.2.2.2/docs/Control-Exception-Lifted.html</a></p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="managed-process.html" class="btn btn-neutral float-right" title="4. Distributed-process platform" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="managing-topologies.html" class="btn btn-neutral" title="2. Managing Topologies" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Haskell distributed team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>