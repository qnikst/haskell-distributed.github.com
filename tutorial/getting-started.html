

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. Getting Started &mdash; Cloud Haskell User Guide</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Cloud Haskell User Guide" href="../index.html"/>
        <link rel="next" title="3. Getting to know Processes" href="getting-to-know-processes.html"/>
        <link rel="prev" title="1. Overview" href="../overview.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Cloud Haskell
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">1. Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#concurrency-and-distribution">1.1. Concurrency and Distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#what-is-serializable">1.2. What is Serializable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#typed-channels">1.3. Typed Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#linking-and-monitoring">1.4. Linking and monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#stopping-processes">1.5. Stopping Processes</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">2. Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-project">2.1. Setting up the project</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-node">2.2. Creating a node</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sending-messages">2.3. Sending messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#serializable-data">2.4. Serializable Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spawning-remote-processes">2.5. Spawning Remote Processes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting-to-know-processes.html">3. Getting to know Processes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting-to-know-processes.html#processes">3.1. Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-know-processes.html#process-lifetime">3.2. Process Lifetime</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-know-processes.html#monitoring-and-linking">3.3. Monitoring and Linking</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-know-processes.html#getting-process-info">3.4. Getting Process Info</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting-to-messages.html">4. Getting to messaging</a><ul>
<li class="toctree-l2"><a class="reference internal" href="getting-to-messages.html#message-ordering">4.1. Message Ordering</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-messages.html#selective-receive">4.2. Selective Receive</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-messages.html#advanced-mailbox-processing">4.3. Advanced Mailbox Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-messages.html#typed-channels">4.4. Typed Channels</a></li>
<li class="toctree-l2"><a class="reference internal" href="getting-to-messages.html#monad-transformer-stacks">4.5. Monad Transformer Stacks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../architecture/network-transport.html">5. Network Transport Abstraction Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../managing-topologies.html">6. Managing Topologies</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../managing-topologies.html#overview">6.1. Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../managing-topologies.html#a-simple-example">6.2. A Simple Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../managing-topologies.html#master-slave-configurations">6.3. Master Slave Configurations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../managing-topologies.html#other-topologies-and-backends">6.4. Other Topologies and Backends</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../managed-process.html">7. Distributed-process platform</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../managed-process.html#managed-process-tutorial">7.1. Managed Process Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#introduction">7.1.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#managed-processes">7.1.2. Managed Processes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#a-basic-example">7.1.3. A Basic Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#building-a-task-queue">7.1.4. Building a Task Queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#implementing-the-client">7.1.5. Implementing the client</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#implementing-the-server">7.1.6. Implementing the server</a></li>
<li class="toctree-l3"><a class="reference internal" href="../managed-process.html#making-use-of-async">7.1.7. Making use of Async</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5ch.html">8. ![Sup1: ][sup1]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5ch.html#sup2-sup2">9. ![Sup2: ][sup2]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5ch.html#sup3-sup3">10. ![Sup3: ][sup3]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6ch.html">11. Advanced Managed Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial-NT2.html">12. Programming with Network.Transport</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Cloud Haskell</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>2. Getting Started</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/tutorial/getting-started.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>2. Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>In order to go through this tutorial, you will need a working Haskell
environment. If you don&#8217;t already have one follow the instructions
<a class="reference external" href="https://www.haskell.org/downloads">here</a> to install the compiler and
then
<a class="reference external" href="https://docs.haskellstack.org/en/stable/README">go here</a>
to install <code class="docutils literal"><span class="pre">stack</span></code>, a popular build tool for Haskell projects.</p>
<p>Once you&#8217;re up and running, you&#8217;ll want to get hold of the
<a class="reference external" href="http://hackage.haskell.org/package/distributed-process">distributed-process</a> library and a choice of network transport
backend. This guide will use the <a class="reference external" href="http://hackage.haskell.org/package/network-transport-tcp">network-transport-tcp</a> backend, but
other backends are available on <a class="reference external" href="https://hackage.haskell.org">Hackage</a>
and <a class="reference external" href="https://github.com">GitHub</a>.</p>
<div class="section" id="setting-up-the-project">
<h2>2.1. Setting up the project<a class="headerlink" href="#setting-up-the-project" title="Permalink to this headline">¶</a></h2>
<p>Starting a new Cloud Haskell project using <code class="docutils literal"><span class="pre">stack</span></code> is as easy as</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="nv">$ </span>stack new
</pre></div>
</div>
<p>in a fresh new directory. This will populate the directory with
a number of files, chiefly <code class="docutils literal"><span class="pre">stack.yaml</span></code> and <code class="docutils literal"><span class="pre">*.cabal</span></code> metadata files
for the project. You&#8217;ll want to add <code class="docutils literal"><span class="pre">distributed-process</span></code> and
<code class="docutils literal"><span class="pre">network-transport-tcp</span></code> to the <code class="docutils literal"><span class="pre">build-depends</span></code> stanza of the
executable section.</p>
</div>
<div class="section" id="creating-a-node">
<h2>2.2. Creating a node<a class="headerlink" href="#creating-a-node" title="Permalink to this headline">¶</a></h2>
<p>Cloud Haskell&#8217;s <code class="docutils literal"><span class="pre">lightweight</span> <span class="pre">processes</span></code> reside on a &#8220;node&#8221;, which must
be initialised with a network transport implementation and a remote table.
The latter is required so that physically separate nodes can identify known
objects in the system (such as types and functions) when receiving messages
from other nodes. We will look at inter-node communication later, for now
it will suffice to pass the default remote table, which defines the built-in
types that Cloud Haskell needs at a minimum in order to run.</p>
<p>In <code class="docutils literal"><span class="pre">app/Main.hs</span></code>, we start with our imports:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Network.Transport.TCP</span> <span class="p">(</span><span class="nf">createTransport</span><span class="p">,</span> <span class="nf">defaultTCPParameters</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Node</span>
</pre></div>
</div>
<p>Our TCP network transport backend needs an IP address and port to get started
with:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">Right</span> <span class="n">t</span> <span class="ow">&lt;-</span> <span class="n">createTransport</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="s">&quot;10501&quot;</span> <span class="n">defaultTCPParameters</span>
  <span class="n">node</span> <span class="ow">&lt;-</span> <span class="n">newLocalNode</span> <span class="n">t</span> <span class="n">initRemoteTable</span>
  <span class="o">....</span>
</pre></div>
</div>
<p>And now we have a running node.</p>
</div>
<div class="section" id="sending-messages">
<h2>2.3. Sending messages<a class="headerlink" href="#sending-messages" title="Permalink to this headline">¶</a></h2>
<p>We start a new process by evaluating <a class="reference external" href="https://hackage.haskell.org/package/distributed-process-0.6.1/docs/Control-Distributed-Process-Node.html#v:runProcess">runProcess</a>,
which takes a node and a <code class="docutils literal"><span class="pre">Process</span></code> action to run, because our concurrent code
will run in the <code class="docutils literal"><span class="pre">Process</span></code> monad. Each process has an identifier associated to it.
The process id can be used to send messages to the running process - here we will send one
to ourselves!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- in main</span>
<span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">runProcess</span> <span class="n">node</span> <span class="o">$</span> <span class="kr">do</span>
  <span class="c1">-- get our own process id</span>
  <span class="n">self</span> <span class="ow">&lt;-</span> <span class="n">getSelfPid</span>
  <span class="n">send</span> <span class="n">self</span> <span class="s">&quot;hello&quot;</span>
  <span class="n">hello</span> <span class="ow">&lt;-</span> <span class="n">expect</span> <span class="ow">::</span> <span class="kt">Process</span> <span class="kt">String</span>
  <span class="n">liftIO</span> <span class="o">$</span> <span class="n">putStrLn</span> <span class="n">hello</span>
<span class="nf">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Note that we haven&#8217;t deadlocked our own thread by sending to and receiving
from its mailbox in this fashion. Sending messages is a completely
asynchronous operation - even if the recipient doesn&#8217;t exist, no error will be
raised and evaluating <code class="docutils literal"><span class="pre">send</span></code> will not block the caller, even if the caller is
sending messages to itself.</p>
<p>Each process also has a <em>mailbox</em> associated with it. Messages sent to
a process are queued in this mailbox. A process can pop a message out of its
mailbox using <code class="docutils literal"><span class="pre">expect</span></code> or the <code class="docutils literal"><span class="pre">receive*</span></code> family of functions. If no message of
the expected type is in the mailbox currently, the process will block until
there is. Messages in the mailbox are ordered by time of arrival.</p>
<p>Let&#8217;s spawn two processes on the same node and have them talk to each other:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Node</span>
<span class="kr">import</span> <span class="nn">Network.Transport.TCP</span> <span class="p">(</span><span class="nf">createTransport</span><span class="p">,</span> <span class="nf">defaultTCPParameters</span><span class="p">)</span>

<span class="nf">replyBack</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">ProcessId</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">replyBack</span> <span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="ow">=</span> <span class="n">send</span> <span class="n">sender</span> <span class="n">msg</span>

<span class="nf">logMessage</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">logMessage</span> <span class="n">msg</span> <span class="ow">=</span> <span class="n">say</span> <span class="o">$</span> <span class="s">&quot;handling &quot;</span> <span class="o">++</span> <span class="n">msg</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">Right</span> <span class="n">t</span> <span class="ow">&lt;-</span> <span class="n">createTransport</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="s">&quot;10501&quot;</span> <span class="n">defaultTCPParameters</span>
  <span class="n">node</span> <span class="ow">&lt;-</span> <span class="n">newLocalNode</span> <span class="n">t</span> <span class="n">initRemoteTable</span>
  <span class="n">runProcess</span> <span class="n">node</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="c1">-- Spawn another worker on the local node</span>
    <span class="n">echoPid</span> <span class="ow">&lt;-</span> <span class="n">spawnLocal</span> <span class="o">$</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="c1">-- Test our matches in order against each message in the queue</span>
      <span class="n">receiveWait</span> <span class="p">[</span><span class="n">match</span> <span class="n">logMessage</span><span class="p">,</span> <span class="n">match</span> <span class="n">replyBack</span><span class="p">]</span>

    <span class="c1">-- The `say` function sends a message to a process registered as &quot;logger&quot;.</span>
    <span class="c1">-- By default, this process simply loops through its mailbox and sends</span>
    <span class="c1">-- any received log message strings it finds to stderr.</span>

    <span class="n">say</span> <span class="s">&quot;send some messages!&quot;</span>
    <span class="n">send</span> <span class="n">echoPid</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">self</span> <span class="ow">&lt;-</span> <span class="n">getSelfPid</span>
    <span class="n">send</span> <span class="n">echoPid</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>

    <span class="c1">-- `expectTimeout` waits for a message or times out after &quot;delay&quot;</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">expectTimeout</span> <span class="mi">1000000</span>
    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
      <span class="c1">-- Die immediately - throws a ProcessExitException with the given reason.</span>
      <span class="kt">Nothing</span>  <span class="ow">-&gt;</span> <span class="n">die</span> <span class="s">&quot;nothing came back!&quot;</span>
      <span class="kt">Just</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="n">say</span> <span class="o">$</span> <span class="s">&quot;got &quot;</span> <span class="o">++</span> <span class="n">s</span> <span class="o">++</span> <span class="s">&quot; back!&quot;</span>

    <span class="c1">-- Without the following delay, the process sometimes exits before the messages are exchanged.</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">threadDelay</span> <span class="mi">2000000</span>
</pre></div>
</div>
<p>Note that we&#8217;ve used <code class="docutils literal"><span class="pre">receiveWait</span></code> this time around to get a message.
<code class="docutils literal"><span class="pre">receiveWait</span></code> and similarly named functions can be used with the
[<code class="docutils literal"><span class="pre">Match</span></code> data type][5] to provide a range of advanced message
processing capabilities. The <code class="docutils literal"><span class="pre">match</span></code> primitive allows you to construct
a &#8220;potential message handler&#8221; and have it evaluated against received
(or incoming) messages. Think of a list of <code class="docutils literal"><span class="pre">Match</span></code>es as the
distributed equivalent of a pattern match. As with <code class="docutils literal"><span class="pre">expect</span></code>, if the
mailbox does not contain a message that can be matched, the evaluating
process will be blocked until a message arrives which _can_ be
matched.</p>
<p>In the <em>echo server</em> above, our first match prints out whatever string it
receives. If the first message in our mailbox is not a <code class="docutils literal"><span class="pre">String</span></code>, then our
second match is evaluated. Thus, given a tuple <code class="docutils literal"><span class="pre">t</span> <span class="pre">::</span> <span class="pre">(ProcessId,</span> <span class="pre">String)</span></code>, it
will send the <code class="docutils literal"><span class="pre">String</span></code> component back to the sender&#8217;s <code class="docutils literal"><span class="pre">ProcessId</span></code>. If neither
match succeeds, the echo server blocks until another message arrives and tries
again.</p>
</div>
<div class="section" id="serializable-data">
<h2>2.4. Serializable Data<a class="headerlink" href="#serializable-data" title="Permalink to this headline">¶</a></h2>
<p>Processes may send any datum whose type implements the <code class="docutils literal"><span class="pre">Serializable</span></code>
typeclass, defined as:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Binary</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializable</span> <span class="n">a</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Binary</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Typeable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Serializable</span> <span class="n">a</span>
</pre></div>
</div>
<p>That is, any type that is <code class="docutils literal"><span class="pre">Binary</span></code> and <code class="docutils literal"><span class="pre">Typeable</span></code> is <code class="docutils literal"><span class="pre">Serializable</span></code>. This is
the case for most of Cloud Haskell&#8217;s primitive types as well as many standard
data types. For custom data types, the <code class="docutils literal"><span class="pre">Typeable</span></code> instance is always
given by the compiler, and the <code class="docutils literal"><span class="pre">Binary</span></code> instance can be auto-generated
too in most cases, e.g.:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class="cm">{-# LANGUAGE DeriveGeneric #-}</span>

<span class="kr">data</span> <span class="kt">T</span> <span class="ow">=</span> <span class="kt">T</span> <span class="kt">Int</span> <span class="kt">Char</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Generic</span><span class="p">,</span> <span class="kt">Typeable</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Binary</span> <span class="kt">T</span>
</pre></div>
</div>
</div>
<div class="section" id="spawning-remote-processes">
<h2>2.5. Spawning Remote Processes<a class="headerlink" href="#spawning-remote-processes" title="Permalink to this headline">¶</a></h2>
<p>We saw above that the behaviour of processes is determined by an action in the
<code class="docutils literal"><span class="pre">Process</span></code> monad. However, actions in the <code class="docutils literal"><span class="pre">Process</span></code> monad, no more serializable
than actions in the <code class="docutils literal"><span class="pre">IO</span></code> monad. If we can&#8217;t serialize actions, then how can we
spawn processes on remote nodes?</p>
<p>The solution is to consider only <em>static</em> actions and compositions thereof.
A static action is always defined using a closed expression (intuitively, an
expression that could in principle be evaluated at compile-time since it does
not depend on any runtime arguments). The type of static actions in Cloud
Haskell is <code class="docutils literal"><span class="pre">Closure</span> <span class="pre">(Process</span> <span class="pre">a)</span></code>. More generally, a value of type <code class="docutils literal"><span class="pre">Closure</span> <span class="pre">b</span></code>
is a value that was constructed explicitly as the composition of symbolic
pointers and serializable values. Values of type <code class="docutils literal"><span class="pre">Closure</span> <span class="pre">b</span></code> are serializable,
even if values of type <code class="docutils literal"><span class="pre">b</span></code> might not be. For instance, while we can&#8217;t in general
send actions of type <code class="docutils literal"><span class="pre">Process</span> <span class="pre">()</span></code>, we can construct a value of type <code class="docutils literal"><span class="pre">Closure</span>
<span class="pre">(Process</span> <span class="pre">())</span></code> instead, containing a symbolic name for the action, and send
that instead. So long as the remote end understands the same meaning for the
symbolic name, this works just as well. A remote spawn then, takes a static
action and sends that across the wire to the remote node.</p>
<p>Static actions are not easy to construct by hand, but fortunately Cloud
Haskell provides a little bit of Template Haskell to help. If <code class="docutils literal"><span class="pre">f</span> <span class="pre">::</span> <span class="pre">T1</span> <span class="pre">-&gt;</span> <span class="pre">T2</span></code>
then</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">$</span><span class="p">(</span><span class="n">mkClosure</span> <span class="n">&#39;f</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">T1</span> <span class="ow">-&gt;</span> <span class="kt">Closure</span> <span class="kt">T2</span>
</pre></div>
</div>
<p>You can turn any top-level unary function into a <code class="docutils literal"><span class="pre">Closure</span></code> using <code class="docutils literal"><span class="pre">mkClosure</span></code>.
For curried functions, you&#8217;ll need to uncurry them first (i.e. &#8220;tuple up&#8221; the
arguments). However, to ensure that the remote side can adequately interpret
the resulting <code class="docutils literal"><span class="pre">Closure</span></code>, you&#8217;ll need to add a mapping in a so-called <em>remote
table</em> associating the symbolic name of a function to its value. Processes can
only be successfully spawned on remote nodes if all these remote nodes have
the same remote table as the local one.</p>
<p>We need to configure our remote table (see the [API reference][6] for
more details) and the easiest way to do this, is to let the library
generate the relevant code for us. For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">sampleTask</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">TimeInterval</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">sampleTask</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sleep</span> <span class="n">t</span> <span class="o">&gt;&gt;</span> <span class="n">say</span> <span class="n">s</span>

<span class="nf">remotable</span> <span class="p">[</span><span class="n">&#39;sampleTask</span><span class="p">]</span>
</pre></div>
</div>
<p>The last line is a top-level Template Haskell splice. At the call site for
<code class="docutils literal"><span class="pre">spawn</span></code>, we can construct a <code class="docutils literal"><span class="pre">Closure</span></code> corresponding to an application of
<code class="docutils literal"><span class="pre">sampleTask</span></code> like so:</p>
<p>The call to <code class="docutils literal"><span class="pre">remotable</span></code> implicitly generates a remote table by inserting
a top-level definition <code class="docutils literal"><span class="pre">__remoteTable</span> <span class="pre">::</span> <span class="pre">RemoteTable</span> <span class="pre">-&gt;</span> <span class="pre">RemoteTable</span></code> in our
module for us. We compose this with other remote tables in order to come up
with a final, merged remote table for all modules in our program:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="cm">{-# LANGUAGE TemplateHaskell #-}</span>

<span class="kr">import</span> <span class="nn">Control.Concurrent</span> <span class="p">(</span><span class="nf">threadDelay</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forever</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Closure</span>
<span class="kr">import</span> <span class="nn">Control.Distributed.Process.Node</span>
<span class="kr">import</span> <span class="nn">Network.Transport.TCP</span> <span class="p">(</span><span class="nf">createTransport</span><span class="p">,</span> <span class="nf">defaultTCPParameters</span><span class="p">)</span>

<span class="nf">sampleTask</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Process</span> <span class="nb">()</span>
<span class="nf">sampleTask</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">liftIO</span> <span class="p">(</span><span class="n">threadDelay</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">say</span> <span class="n">s</span>

<span class="nf">remotable</span> <span class="p">[</span><span class="n">&#39;sampleTask</span><span class="p">]</span>

<span class="nf">myRemoteTable</span> <span class="ow">::</span> <span class="kt">RemoteTable</span>
<span class="nf">myRemoteTable</span> <span class="ow">=</span> <span class="kt">Main</span><span class="o">.</span><span class="n">__remoteTable</span> <span class="n">initRemoteTable</span>

<span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kt">Right</span> <span class="n">transport</span> <span class="ow">&lt;-</span> <span class="n">createTransport</span> <span class="s">&quot;127.0.0.1&quot;</span> <span class="s">&quot;10501&quot;</span> <span class="n">defaultTCPParameters</span>
  <span class="n">node</span> <span class="ow">&lt;-</span> <span class="n">newLocalNode</span> <span class="n">transport</span> <span class="n">myRemoteTable</span>
  <span class="n">runProcess</span> <span class="n">node</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">us</span> <span class="ow">&lt;-</span> <span class="n">getSelfNode</span>
    <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">spawnLocal</span> <span class="o">$</span> <span class="n">sampleTask</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="s">&quot;using spawnLocal&quot;</span><span class="p">)</span>
    <span class="n">pid</span> <span class="ow">&lt;-</span> <span class="n">spawn</span> <span class="n">us</span> <span class="o">$</span> <span class="o">$</span><span class="p">(</span><span class="n">mkClosure</span> <span class="n">&#39;sampleTask</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="s">&quot;using spawn&quot;</span><span class="p">)</span>
    <span class="n">liftIO</span> <span class="o">$</span> <span class="n">threadDelay</span> <span class="mi">2000000</span>
</pre></div>
</div>
<p>In the above example, we spawn <code class="docutils literal"><span class="pre">sampleTask</span></code> on node <code class="docutils literal"><span class="pre">us</span></code> in two
different ways:</p>
<ul class="simple">
<li>using <code class="docutils literal"><span class="pre">spawn</span></code>, which expects some node identifier to spawn a process
on along with a <code class="docutils literal"><span class="pre">Closure</span></code> for the action of the process.</li>
<li>using <code class="docutils literal"><span class="pre">spawnLocal</span></code>, a specialization of <code class="docutils literal"><span class="pre">spawn</span></code> for the case when the
node identifier actually refers to the local node (i.e. <code class="docutils literal"><span class="pre">us</span></code>). In
this special case, no serialization is necessary, so passing an
action directly rather than a <code class="docutils literal"><span class="pre">Closure</span></code> works just fine.</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="getting-to-know-processes.html" class="btn btn-neutral float-right" title="3. Getting to know Processes" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../overview.html" class="btn btn-neutral" title="1. Overview" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Haskell distributed team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>