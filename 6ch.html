

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. Advanced Managed Processes &mdash; Cloud Haskell User Guide</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Cloud Haskell User Guide" href="index.html"/>
        <link rel="next" title="9. Programming with Network.Transport" href="tutorial-NT2.html"/>
        <link rel="prev" title="5. ![Sup1: ][sup1]" href="5ch.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Cloud Haskell
          

          
          </a>

          
            
            
              <div class="version">
                0.7
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">1. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="2ch.html">2. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="3ch.html">3. Message Ordering</a></li>
<li class="toctree-l1"><a class="reference internal" href="4ch.html">4. Managed Process Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html">5. ![Sup1: ][sup1]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup2-sup2">6. ![Sup2: ][sup2]</a></li>
<li class="toctree-l1"><a class="reference internal" href="5ch.html#sup3-sup3">7. ![Sup3: ][sup3]</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">8. Advanced Managed Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial-NT2.html">9. Programming with Network.Transport</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Cloud Haskell</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>8. Advanced Managed Processes</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/6ch.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>&#8212;
layout: tutorial
sections: [&#8216;Introduction&#8217;, &#8216;Unexpected Messages&#8217;, &#8216;Hiding Implementation Details&#8217;, &#8216;Using Typed Channels&#8217;]
categories: tutorial
title: 6. Advanced Managed Processes
&#8212;</p>
<div class="section" id="advanced-managed-processes">
<h1>8. Advanced Managed Processes<a class="headerlink" href="#advanced-managed-processes" title="Permalink to this headline">Â¶</a></h1>
<p>### Introduction</p>
<p>In this tutorial, we will look at some advanced ways of programming Cloud Haskell
using the managed process API.</p>
<p>### Unexpected Messages</p>
<p>The process definition&#8217;s [<cite>UnhandledMessagePolicy</cite>][policy] provides a way for
processes to respond to unexpected inputs. This proves surprisingly important,
since it is always possible for messages to unexpectedly arrive in a process&#8217;
mailbox, either those which do not match the server&#8217;s expected types or which
fail one or more match conditions against the message body.</p>
<p>As we will see shortly, there are various ways to ensure that only certain
messages (i.e., types) are sent to a process, but in the presense of monitoring
and other system management facilities and since the node controller is
responsible - both conceptually and by implementation - for dispatching messages
to each process&#8217; mailbox, it is impractical to make real guarantees about a
process&#8217; total input domain. Such policies are best enforced with session types,
which is part of the Cloud Haskell roadmap, but unconnected to managed processes.</p>
<p>During development, the handy <cite>Log</cite> option will write an info message to the
[_SystemLog_][3] with information about unexpected inputs (including type info),
whilst in production, the obvious choice is between the silent <cite>Drop</cite> and its
explosive sibling, <cite>Terminate</cite>. Since in Cloud Haskell&#8217;s open messaging architecture,
it is impossible to guarantee against unexpected messages (even in the presence</p>
<blockquote>
<div>of advanced protocol enforcement tools such as session types), whichever option</div></blockquote>
<p>is chosen, the server must have some policy for dealing with unexpected messages.</p>
<p>&gt; of application failure and when servers discard messages without notifying their
&gt; clients, deadlocks will quickly ensue!
&#8212;&#8212;</p>
<p>### Hiding Implementation Details</p>
<p>Whilst there is nothing to stop clients from sending messages directly to a
managed process, there are ways to avoid this (in most cases) by hiding our
<cite>ProcessId</cite>, either behind a _newtype_ or some other opaque data structure).
The author of the server is then able to force clients through API calls that
can enforce the required types _and_ ensure that the correct client-server
protocol is used.</p>
<p>In its simplest guise, this technique simply employs the compiler to ensure
that our clients only communicate with us in well-known ways. Let&#8217;s take a
look at this in action, revisiting the well-trodden _math <a href="#id1"><span class="problematic" id="id2">server_</span></a> example
from our previous tutorials:</p>
<p>{% highlight haskell %}
module MathServer</p>
<blockquote>
<div><dl class="docutils">
<dt>( &#8211; client facing API</dt>
<dd>MathServer()</dd>
<dt>, add</dt>
<dd>&#8211; starting/spawning the server process</dd>
</dl>
<p>, launchMathServer
) where</p>
</div></blockquote>
<p>import .... &#8211; elided</p>
<dl class="docutils">
<dt>newtype MathServer = MathServer { mathServerPid :: ProcessId }</dt>
<dd>deriving (Typeable)</dd>
</dl>
<p>&#8211; other types/details elided</p>
<p>add :: MathServer -&gt; Double -&gt; Double -&gt; Process Double
add MathServer{..} = call mathServerPid . Add</p>
<p>launchMathServer :: Process MathServer
launchMathServer = launch &gt;&gt;= return . MathServer</p>
<blockquote>
<div><dl class="docutils">
<dt>where launch =</dt>
<dd><dl class="first docutils">
<dt>let server = statelessProcess {</dt>
<dd>apiHandlers = [ <a href="#id3"><span class="problematic" id="id4">handleCall_</span></a> ((Add x y) -&gt; return (x + y)) ]</dd>
</dl>
<p class="last">, unhandledMessagePolicy = Drop
}
in spawnLocal $ start () (statelessInit Infinity) server &gt;&gt; return ()</p>
</dd>
</dl>
</div></blockquote>
<p>{% endhighlight %}</p>
<p>What we&#8217;ve changed here is the _handle_ clients use to communicate with the
process, hiding the <cite>ProcessId</cite> behind a newtype and forcing client code to
use the <cite>MathServer</cite> handle to call our API functions. Since the <cite>MathServer</cite>
newtype wraps a <cite>ProcessId</cite>, it is <cite>Serializable</cite> and can be sent to remote
clients if needed.</p>
<p>&gt; will remain private due to the presence of the [management][mgmt] and
&gt; [tracing/debugging][dbg] APIs in distributed-process. Servers that use the
&gt; distributed-process monitoring APIs, must also be prepared to deal with monitor
&gt; signals (such as the ubiquitous <cite>ProcessMonitorNotification</cite>) arriving as _info
&gt; <a href="#id5"><span class="problematic" id="id6">messages_</span></a>, since these are always dispatched directly to our mailbox via the
&gt; node controller.
&#8212;&#8212;</p>
<p>Another reason to use a _server <a href="#id7"><span class="problematic" id="id8">handle_</span></a> like this, instead of a raw <cite>ProcessId</cite>,
is to ensure type compatibility between client and server, in cases where the
server has been written to generically deal with various types whilst the client
needs to reify its calls/casts over a specific type. To demonstrate this
approach, we&#8217;ll consider the [<cite>Registry</cite>][1] module, which provides an enhanced
_process <a href="#id9"><span class="problematic" id="id10">registry_</span></a> that provides name registration services and also behaves
like a per-process, global key-value store.</p>
<p>Each <cite>Registry</cite> server deals with specific types of keys and values. Allowing
clients to send and receive instructions pertaining to a registry server without
knowing the exact types the server was _spawned_ to handle, is a recipe for
disaster, since the client is very likely to block indefinitely if the expected
request types don&#8217;t match up, since the server will ignore them.
We can alleviate this problem using phantom type parameters, storing only
the real <cite>ProcessId</cite> we need to communicate with the server, whilst utilising
the compiler to ensure the correct types are assumed at both ends.</p>
<p>{% highlight haskell %}
data Registry k v = Registry { registryPid :: ProcessId }</p>
<blockquote>
<div>deriving (Typeable, Generic, Show, Eq)</div></blockquote>
<p>instance (Keyable k, Serializable v) =&gt; Binary (Registry k v) where
{% endhighlight %}</p>
<p>In order to start our registry, we need to know the specific <cite>k</cite> and <cite>v</cite> types,
but we do not real values of these, so we use scoped type variables to reify
them when creating the <cite>Registry</cite> handle:</p>
<p>{% highlight haskell %}
start :: forall k v. (Keyable k, Serializable v) =&gt; Process (Registry k v)
start = return . Registry =&lt;&lt; spawnLocal (run (undefined :: Registry k v))</p>
<p>run :: forall k v. (Keyable k, Serializable v) =&gt; Registry k v -&gt; Process ()
run _ =</p>
<blockquote>
<div>MP.pserve () (const $ return $ InitOk initState Infinity) serverDefinition
&#8211; etc....</div></blockquote>
<p>{% endhighlight %}</p>
<p>Having wrapped the <cite>ProcessId</cite> in a newtype that ensures the types with which
the server was initialised are respected by clients, we use the same approach
as earlier to force clients of our API to interact with the server not only
using the requisite call/cast protocol, but also providing the correct types
in the form of a valid handle.</p>
<p>{% highlight haskell %}
addProperty :: (Keyable k, Serializable v)</p>
<blockquote>
<div>=&gt; Registry k v -&gt; k -&gt; v -&gt; Process RegisterKeyReply</div></blockquote>
<p>addProperty reg k v = ....
{% endhighlight %}</p>
<p>So long as we only expose <cite>Registry</cite> newtype construction via our <cite>start</cite> API,
clients cannot forge a registry handle and both client and server can rely on
the compiler to have enforced the correct types for all our interactions.</p>
<p>&gt; possible. Use phantom types along with these _server <a href="#id11"><span class="problematic" id="id12">handles_</span></a>, to ensure
&gt; clients do not send unexpected data to the server.
&#8212;&#8212;</p>
<p>Of course, you might actually _need_ the server&#8217;s <cite>ProcessId</cite> sometimes,
perhaps for monitoring, name registration or similar schemes that operate
explicitly on a <cite>ProcessId</cite>. It is also common to _need_ support for sending
info messages. Some APIs are built on &#8220;plain old messaging&#8221; via <cite>send</cite> and
therefore completely hiding your <cite>ProcessId</cite> becomes the right way to expose
an API to your clients, but the wrong way to expose your process to other APIs
it is utilising.</p>
<p>In these situations, the [<cite>Resolvable</cite>][rsbl] and [<cite>Routable</cite>][rtbl] typeclasses
are your friend. By providing a <cite>Resolvable</cite> instance, you can expose your
<cite>ProcessId</cite> to peers that really need it, whilst documenting (via the design
decision to only expose the <cite>ProcessId</cite> via a typeclass) the need to use the
handle in client code.</p>
<p>{% highlight haskell %}
instance Resolvable (Registry k v) where</p>
<blockquote>
<div>resolve = return . Just . registryPid</div></blockquote>
<p>{% endhighlight %}</p>
<p>The [<cite>Routable</cite>][rtbl] typeclass provides a means to dispatch messages without
having to know the implementation details behind the scenes. This provides us
with a means for APIs that need to send messages directly to our process to do
so via the opaque handle, without us exposing the <cite>ProcessId</cite> to them directly.
(Of course, such APIs have to be written with [<cite>Routable</cite>][rtbl] in mind!)</p>
<p>There is a default (and fairly efficient) instance of [<cite>Routable</cite>][rtbl] for all
[<cite>Resolvable</cite>][rsbl] instances, so it is usually enough to implement the latter.
An explicit implementation for our <cite>Registry</cite> would look like this:</p>
<p>{% highlight haskell %}
instance Routable (Registry k v) where</p>
<blockquote>
<div>sendTo       reg msg = send (registryPid reg) msg
unsafeSendTo reg msg = unsafeSend (registryPid reg) msg</div></blockquote>
<p>{% endhighlight %}</p>
<p>Similar typeclasses are provided for the many occaisions when you need to link
to or kill a process without knowing its <cite>ProcessId</cite>:</p>
<p>{% highlight haskell %}
class Linkable a where</p>
<blockquote>
<div>&#8211; | Create a /link/ with the supplied object.
linkTo :: a -&gt; Process ()</div></blockquote>
<dl class="docutils">
<dt>class Killable a where</dt>
<dd>killProc :: a -&gt; String -&gt; Process ()
exitProc :: (Serializable m) =&gt; a -&gt; m -&gt; Process ()</dd>
</dl>
<p>{% endhighlight %}</p>
<p>Again, there are default instances of both typeclasses for all [<cite>Resolvable</cite>][rsbl]
types, so it is enough to provide just that instance for your handles.</p>
<p>### Using Typed Channels</p>
<p>Typed Channels can be used in two ways via the managed process API, either as
inputs to the server or as a _reply <a href="#id13"><span class="problematic" id="id14">channel_</span></a> for RPC style interactions that
offer an alternative to using <cite>call</cite>.</p>
<p>#### Reply Channels</p>
<p>When using the <cite>call</cite> API, the server can reply  with a datum that doesn&#8217;t
match the type(s) the client expects. This will cause the client to either
deadlock or timeout, depending on which variant of <cite>call</cite> was used. This isn&#8217;t
usually a problem, since the server author also writes the client facing API(s)
and can therefore carefully check that the correct types are being returned.
That&#8217;s still potentially error prone however, and using a <cite>SendPort</cite> as a reply
channel can make it easier to spot potential type discrepancies.</p>
<p>The machinery behind _reply <a href="#id15"><span class="problematic" id="id16">channels_</span></a> is very simple: We create a new channel
for the reply and pass the <cite>SendPort</cite> to the server along with our input message.
The server is responsible for sending its reply to the given <cite>SendPort</cite> and the
corresponding <cite>ReceivePort</cite> is returned so the caller can wait on it. For course,
if no corresponding handler is present in the server definition, there may be no
reply (and depending on the server&#8217;s <cite>unhandledMessagePolicy</cite>, we may crash the
server).</p>
<p>&gt; of the reply channel, in which case the message will be considered an _unhandled_
&gt; input and dealt with accordingly.
&#8212;&#8212;</p>
<p>Typed channels are better suited to handling deferred client-server RPC calls
than plain inter-process messaging too. The only non-blocking <cite>call</cite> API is based
on [<cite>Async</cite>][2] and its only failure mode is an <cite>AsyncFailed</cite> result containing
a corresponding <cite>ExitReason</cite>. The <cite>callTimeout</cite> API is equally limited, since
once its delay is exceeded (and the call times out), you cannot subsequently
retry listening for the message - the client is on its own at this point, and
has to deal with potentially stray (and un-ordered!) replies using the low
level <cite>flushPendingCalls</cite> API. By using a typed channel for replies, we can avoid
both these issues since after the RPC is initiated, the client can defer obtaining
a reply from the <cite>ReceivePort</cite> until it&#8217;s ready, timeout waiting for the reply
<strong>and</strong> try again at a later time and even wait on the results of multiple RPC
calls (to one or _more_ servers) at the same by merging the ports.</p>
<p>If we wish to block and wait for a reply immediately (just as we would with <cite>call</cite>),
two blocking operations are provided to simplify the task, one of which returns an
<cite>ExitReason</cite> on failure, whilst the other crashes (with the given <cite>ExitReason</cite> of
course!). The implementation is precisely what you&#8217;d expect a blocking _call_ to
do, right up to monitoring the server for potential exit signals (so as not to
deadlock the client if the server dies before replying) - all of which is handled
by <cite>awaitResponse</cite> in the platform&#8217;s <cite>Primitives</cite> module.</p>
<p>{% highlight haskell %}
syncSafeCallChan server msg = do</p>
<blockquote>
<div>rp &lt;- callChan server msg
awaitResponse server [ matchChan rp (return . Right) ]</div></blockquote>
<p>{% endhighlight %}</p>
<p>This might sound like a vast improvement on the usual combination of a client
API that uses <cite>call</cite> and a corresponding <cite>handleCall</cite> in the process definition,
with the programmer left to ensure the types always match up. In reality, there
is a trade-off to be made however. Using the <cite>handleCall</cite> APIs means that our server
side code can use the fluent server API for state changes, immediate replies and
so on. None of these features will work with the corollary family of
<cite>handleRpcChan</cite> functions. Whether or not the difference is merely aesthetic, we
leave as a question for the reader to determine. The following example demonstrates
the use of reply channels:</p>
<p>{% highlight haskell %}
&#8211; two versions of the same handler, one for calls, one for typed (reply) channels</p>
<p>data State
data Input
data Output</p>
<p>&#8211; typeable and binary instances ommitted for brevity</p>
<p>&#8211; client code</p>
<p>callDemo :: ProcessId -&gt; Process Output
callDemo server = call server Input</p>
<p>chanDemo :: ProcessId -&gt; Process Output
chanDemo server = syncCallChan server Input</p>
<p>&#8211; server code (process definition ommitted for brevity)</p>
<p>callHandler :: Dispatcher State
callHandler = handleCall $ state Input -&gt; reply Output state</p>
<p>chanHandler :: Dispatcher State
chanHandler = handleRpcChan $ state port Input -&gt; replyChan port Output &gt;&gt; continue state
{% endhighlight %}</p>
<p>&gt; whereas the <cite>call</cite> API forces you to decide how to respond (to the client) via the
&gt; <cite>ProcessReply</cite> type which server-side call _handlers_ have to evaluate to.
&#8212;&#8212;</p>
<p>#### Input (Control) Channels</p>
<p>An alternative input plane managed process servers; _Control <a href="#id17"><span class="problematic" id="id18">Channels_</span></a> provide a
number of benefits above and beyond both the standard <cite>call</cite> and <cite>cast</cite> APIs and the
use of reply channels. These include efficiency - _typed <a href="#id19"><span class="problematic" id="id20">channels_</span></a> are very lightweight
constructs in general! - and type safety, as well as giving the server the ability to
prioritise information sent on control channels over other traffic.</p>
<p>Using typed channels as inputs to your managed process is _the_ most efficient way
to enable client-server communication, particularly for intra-node traffic, due to
their internal use of STM (and in particular, its use during selective receives).
Control channels can provide an alternative to prioritised process definitions, since
their use of channels ensures that, providing the control channel handler(s) occur
in the process definition&#8217;s <cite>apiHandlers</cite> list before the other dispatchers, any
messages received on those channels will be prioritised over other traffic. This is
the most efficient kind of prioritisation - not much use if you need to prioritise
_info <a href="#id21"><span class="problematic" id="id22">messages_</span></a> of course, but very useful if _control <a href="#id23"><span class="problematic" id="id24">messages_</span></a> need to be given
priority over other inputs.</p>
<p>&gt; though, since they _are_ represented by a <cite>Dispatcher</cite> and therefore deemded
&gt; valid entries of the <cite>apiHandlers</cite> field. Upon startup, a prioritised process
&gt; definition that contains control channel dispatchers in its <cite>apiHandlers</cite> will
&gt; immediately exit with the reason <cite>ExitOther &#8220;IllegalControlChannel&#8221;</cite> though.
&#8212;&#8212;</p>
<p>In order to use a typed channel as an input plane, it is necessary to _leak_ the
<cite>SendPort</cite> to your clients somehow. One way would be to <cite>send</cite> it on demand, but the
simplest approach is actually to initialise a handle with all the relevant send ports
and return this to the spawning process via a private channel, MVar or STM (or similar).
Because a <cite>SendPort</cite> is <cite>Serializable</cite>, forwarding them (or the handle they&#8217;re
contained within) is no problem either.</p>
<p>Since typed channels are a one way street, there&#8217;s no direct API support for RPC calls
when using them to send data to a server. The work-around for this remains simple,
type-safe and elegant though: we encode a reply channel into our command/request datum
so the server knows where (and with what type) to reply. This does increase the amount
of boilerplate code the client-facing API has to endure, but it&#8217;s a small price to pay
for the efficiency and additional type safety provided.</p>
<p>First, we&#8217;ll look at an example of a single control channel being used with the
<cite>chanServe</cite> API. This handles the messy details of passing the control channel back
to the calling process, at least to some extent. For this example, we&#8217;ll examine the
[<cite>Mailbox</cite>][mailbox] module, since this combines a fire-and-forget control channel with
an opaque server handle.</p>
<p>{% highlight haskell %}
&#8211; our handle is fairly simple
data Mailbox = Mailbox { pid   :: !ProcessId</p>
<blockquote>
<div>, cchan :: !(ControlPort ControlMessage)
} deriving (Typeable, Generic, Eq)</div></blockquote>
<p>instance Binary Mailbox where</p>
<dl class="docutils">
<dt>instance Linkable Mailbox where</dt>
<dd>linkTo = link . pid</dd>
<dt>instance Resolvable Mailbox where</dt>
<dd>resolve = return . Just . pid</dd>
</dl>
<p>&#8211; lots of details elided....</p>
<p>&#8211; Starting the mailbox involves both spawning, and passing back the process id,
&#8211; plus we need to get our hands on a control port for the control channel!</p>
<dl class="docutils">
<dt>doStartMailbox :: Maybe SupervisorPid</dt>
<dd>-&gt; ProcessId
-&gt; BufferType
-&gt; Limit
-&gt; Process Mailbox</dd>
<dt>doStartMailbox mSp p b l = do</dt>
<dd><p class="first">bchan &lt;- liftIO $ newBroadcastTChanIO
rchan &lt;- liftIO $ atomically $ dupTChan bchan
spawnLocal (maybeLink mSp &gt;&gt; runMailbox bchan p b l) &gt;&gt;= pid -&gt; do</p>
<blockquote>
<div>cc &lt;- liftIO $ atomically $ readTChan rchan
return $ Mailbox pid cc  &#8211; return our opaque handle!</div></blockquote>
<dl class="last docutils">
<dt>where</dt>
<dd>maybeLink Nothing   = return ()
maybeLink (Just p&#8217;) = link p&#8217;</dd>
</dl>
</dd>
<dt>runMailbox :: TChan (ControlPort ControlMessage)</dt>
<dd>-&gt; ProcessId
-&gt; BufferType
-&gt; Limit
-&gt; Process ()</dd>
<dt>runMailbox tc pid buffT maxSz = do</dt>
<dd>link pid
tc&#8217; &lt;- liftIO $ atomically $ dupTChan tc
MP.chanServe (pid, buffT, maxSz) (mboxInit tc&#8217;) (processDefinition pid tc)</dd>
<dt>mboxInit :: TChan (ControlPort ControlMessage)</dt>
<dd>-&gt; InitHandler (ProcessId, BufferType, Limit) State</dd>
<dt>mboxInit tc (pid, buffT, maxSz) = do</dt>
<dd>cc &lt;- liftIO $ atomically $ readTChan tc
return $ InitOk (State Seq.empty $ defaultState buffT maxSz pid cc) Infinity</dd>
<dt>processDefinition :: ProcessId</dt>
<dd>-&gt; TChan (ControlPort ControlMessage)
-&gt; ControlChannel ControlMessage
-&gt; Process (ProcessDefinition State)</dd>
<dt>processDefinition pid tc cc = do</dt>
<dd><p class="first">liftIO $ atomically $ writeTChan tc $ channelControlPort cc
return $ defaultProcess { apiHandlers = [</p>
<blockquote class="last">
<div><blockquote>
<div><blockquote>
<div>handleControlChan     cc handleControlMessages</div></blockquote>
<p>, Restricted.handleCall handleGetStats
]</p>
</div></blockquote>
<dl class="docutils">
<dt>, infoHandlers = [ handleInfo handlePost</dt>
<dd>, handleRaw  handleRawInputs ]</dd>
</dl>
<p>, unhandledMessagePolicy = DeadLetter pid
} :: Process (ProcessDefinition State)</p>
</div></blockquote>
</dd>
</dl>
<p>{% endhighlight %}</p>
<p>Since the rest of the mailbox initialisation code is quite complex, we&#8217;ll leave it
there for now. The important details to take away are the use of <cite>chanServe</cite>
and its requirement for a thunk that initialises the <cite>ProcessDefinition</cite>, so it can
perform IO - a pre-requisite to sharing the control channels with the spawning process,
which must use STM or something similar in order to share data with the newly spawned
server&#8217;s initialisation code. In our case, we want to pass the control port from the
thunk passed to <cite>chanServe</cite> back to both the spawning process _and_ the init function
(which is normally de-coupled from the initialising thunk), which makes this a good
example of how to utilise a broadcast TChan (or TQueue) to share control plane
structures during initialisation.</p>
<hr class="docutils" />
<p>Now we&#8217;ll cook up another (contrived) example that uses multiple typed control channels,
demonstrating how to create control channels explicitly, how to obtain a <cite>ControlPort</cite>
for each one, one way of passing these back to the process spawning the server (so as
to fill in the opaque server handle) and how to utilise these in your client code,
complete with the use of typed reply channels. This code will not use <cite>chanServe</cite>,
since _that_ API only supports a single control channel - the original purpose behind
the control channel concept - and instead, we&#8217;ll create the process loop ourselves,
using the exported low level <cite>recvLoop</cite> function.</p>
<p>{% highlight haskell %}</p>
<p>type NumRequests = Int</p>
<dl class="docutils">
<dt>data EchoServer = EchoServer { echoRequests :: ControlPort String</dt>
<dd><blockquote class="first">
<div>, statRequests :: ControlPort NumRequests
, serverPid    :: ProcessId
}</div></blockquote>
<p class="last">deriving (Typeable, Generic)</p>
</dd>
</dl>
<p>instance Binary EchoServer where
instance NFData EchoServer where</p>
<dl class="docutils">
<dt>instance Resolvable EchoServer where</dt>
<dd>resolve = return . Just . serverPid</dd>
<dt>instance Linkable EchoServer where</dt>
<dd>linkTo = link . serverPid</dd>
</dl>
<p>&#8211; The server takes a String and returns it verbatim</p>
<dl class="docutils">
<dt>data EchoRequest = EchoReq !String !(SendPort String)</dt>
<dd>deriving (Typeable, Generic)</dd>
</dl>
<p>instance Binary EchoRequest where
instance NFData EchoRequest where</p>
<dl class="docutils">
<dt>data StatsRequest = StatsReq !(SendPort Int)</dt>
<dd>deriving (Typeable, Generic)</dd>
</dl>
<p>instance Binary StatsRequest where
instance NFData StatsRequest where</p>
<p>&#8211; client code</p>
<p>echo :: EchoServer -&gt; String -&gt; Process String
echo h s = do</p>
<blockquote>
<div>(sp, rp) &lt;- newChan
let req = EchoReq s sp
sendControlMessage (echoRequests h) req
receiveWait [ matchChan rp return ]</div></blockquote>
<p>stats :: EchoServer -&gt; Process NumRequests
stats h = do</p>
<blockquote>
<div>(sp, rp) &lt;- newChan
let req = StatsReq sp
sendControlMessage (statRequests h) req
receiveWait [ matchChan rp return ]</div></blockquote>
<p>demo :: Process ()
demo = do</p>
<blockquote>
<div><p>server &lt;- spawnEchoServer
foobar &lt;- echo server &#8220;foobar&#8221;
foobar <cite>shouldBe</cite> equalTo &#8220;foobar&#8221;</p>
<p>baz &lt;- echo server &#8220;baz&#8221;
baz <cite>shouldBe</cite> equalTo baz</p>
<p>count &lt;- stats server
count <cite>shouldBe</cite> equalTo (2 :: NumRequests)</p>
</div></blockquote>
<p>&#8211; server code</p>
<p>spawnEchoServer :: Process EchoServer
spawnEchoServer = do</p>
<blockquote>
<div>(sp, rp) &lt;- newChan
pid &lt;- spawnLocal $ runEchoServer sp
(echoPort, statsPort) &lt;- receiveChan rp
return $ EchoServer echoPort statsPort pid</div></blockquote>
<dl class="docutils">
<dt>runEchoServer :: SendPort (ControlPort EchoRequest, ControlPort StatsRequest)</dt>
<dd>-&gt; Process ()</dd>
<dt>runEchoServer portsChan = do</dt>
<dd>echoChan &lt;- newControlChan
echoPort &lt;- channelControlPort echoChan
statChan &lt;- newControlChan
statPort &lt;- channelControlPort statChan
sendChan portsChan (echoPort, statPort)
runProcess (recvLoop $ echoServerDefinition echoChan statChan ) echoServerInit</dd>
</dl>
<p>echoServerInit :: InitHandler () NumRequests
echoServerInit = return $ InitOk (0 :: Int) Infinity</p>
<dl class="docutils">
<dt>echoServerDefinition :: ControlChannel EchoRequest</dt>
<dd>-&gt; ControlChannel StatsRequest
-&gt; ProcessDefinition NumRequests</dd>
<dt>echoServerDefinition echoChan statChan =</dt>
<dd><dl class="first last docutils">
<dt>defaultProcess {</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>apiHandlers = [ handleControlChan echoChan handleEcho</dt>
<dd>, handleControlChan statChan handleStats
]</dd>
</dl>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
</dd>
</dl>
<p>handleEcho :: NumRequests -&gt; EchoRequest -&gt; Process (ProcessAction State)
handleEcho count (EchoReq req replyTo) = do</p>
<blockquote>
<div>replyChan replyTo req  &#8211; echo back the string
continue $ count + 1</div></blockquote>
<p>handleStats :: NumRequests -&gt; StatsRequest -&gt; Process (ProcessAction State)
handleStats count (StatsReq replyTo) = do</p>
<blockquote>
<div>replyChan replyTo count
continue count</div></blockquote>
<p>{% endhighlight %}</p>
<p>Although not very useful, this is a working example. Note that the client must
deal with a <cite>ControlPort</cite> and not the complete <cite>ControlChannel</cite> itself. Also
note that the server is completely responsible for replying (explicitly) to
the client using the send ports supplied in the request data.</p>
<p>&gt; the server code before it can create handlers for them and the client code that
&gt; passes data to them (via the <cite>SendPort</cite>) is bound to exactly the same type(s)!
&gt; Furthermore, adding reply channels (in the form of a <cite>SendPort</cite>) to the request
&gt; types ensures that the replies will be handled correctly as well! As a result,
&gt; there can be no ambiguity about the types involved for _either_ side of the
&gt; client-server relationship and therefore no unhandled messages due to runtime
&gt; type mismatches - the compiler will catch that sort of thing for us!
&#8212;&#8212;</p>
<p>[1]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Service-Registry.html">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Service-Registry.html</a>
[2]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Async.html">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Async.html</a>
[3]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Service-SystemLog.html">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Service-SystemLog.html</a>
[mgmt]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process/Control-Distributed-Process-Management.html">http://hackage.haskell.org/package/distributed-process/Control-Distributed-Process-Management.html</a>
[dbg]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process/Control-Distributed-Process-Debug.html">http://hackage.haskell.org/package/distributed-process/Control-Distributed-Process-Debug.html</a>
[rtbl]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-proces-platforms/Control-Distributed-Process-Platform.html#t:Routable">http://hackage.haskell.org/package/distributed-proces-platforms/Control-Distributed-Process-Platform.html#t:Routable</a>
[rsbl]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform.html#t:Resolvable">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform.html#t:Resolvable</a>
[alert]: /img/alert.png
[info]: /img/info.png
[policy]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-ManagedProcess.html#t:UnhandledMessagePolicy">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-ManagedProcess.html#t:UnhandledMessagePolicy</a>
[mailbox]: <a class="reference external" href="http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Execution-Mailbox.html">http://hackage.haskell.org/package/distributed-process-platform/Control-Distributed-Process-Platform-Execution-Mailbox.html</a></p>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="tutorial-NT2.html" class="btn btn-neutral float-right" title="9. Programming with Network.Transport" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="5ch.html" class="btn btn-neutral" title="5. ![Sup1: ][sup1]" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Haskell distributed team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.7',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>